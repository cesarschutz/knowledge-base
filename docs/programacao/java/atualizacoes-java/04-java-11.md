# 1ï¸âƒ£1ï¸âƒ£ Java 11 LTS (2018)

# ğŸš€ Java 11 LTS - A Nova Era do Java

## ğŸ“– Sobre o Java 11

Java 11 marcou um **divisor de Ã¡guas** na histÃ³ria do Java, sendo a primeira versÃ£o LTS apÃ³s o Java 8. LanÃ§ado em setembro de 2018, trouxe mudanÃ§as significativas como remoÃ§Ã£o de mÃ³dulos legados, APIs modernas e melhorias de performance que definiram o rumo do Java moderno.

## ğŸ’¡ O que sÃ£o JEPs?
Java 11 incluiu 17 JEPs que modernizaram a plataforma, removeram tecnologias legadas e introduziram APIs que se tornaram essenciais no desenvolvimento Java atual.

---

## ğŸŒ APIs de Rede

### ğŸ”¹ JEP 321: HTTP Client (Standard API)

#### â“ O que Ã©?
API nativa moderna para requisiÃ§Ãµes HTTP/1.1 e HTTP/2, substituindo a antiga `HttpURLConnection` e eliminando a necessidade de bibliotecas externas como Apache HttpClient.

#### âš ï¸ Por que Ã© importante?
Oferece uma API moderna, assÃ­ncrona e que suporta HTTP/2 out-of-the-box, reduzindo dependÃªncias externas e melhorando performance das aplicaÃ§Ãµes.

```java
// HTTP GET bÃ¡sico
HttpClient client = HttpClient.newHttpClient();

HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create("https://api.github.com/users/octocat"))
    .header("Accept", "application/json")
    .timeout(Duration.ofSeconds(10))
    .build();

// SÃ­ncrono
HttpResponse<String> response = client.send(request, 
    HttpResponse.BodyHandlers.ofString());

System.out.println("Status: " + response.statusCode());
System.out.println("Body: " + response.body());

// AssÃ­ncrono com CompletableFuture
CompletableFuture<String> asyncResponse = client.sendAsync(request,
    HttpResponse.BodyHandlers.ofString())
    .thenApply(HttpResponse::body);

asyncResponse.thenAccept(System.out::println);
```

#### ğŸš€ HTTP/2 e Features AvanÃ§adas
```java
// Cliente HTTP/2 com configuraÃ§Ã£o customizada
HttpClient client = HttpClient.newBuilder()
    .version(HttpClient.Version.HTTP_2)  // Preferir HTTP/2
    .connectTimeout(Duration.ofSeconds(20))
    .followRedirects(HttpClient.Redirect.NORMAL)
    .authenticator(Authenticator.getDefault())
    .build();

// POST com JSON
String json = """
    {
        "name": "JoÃ£o Silva",
        "age": 30,
        "email": "joao@example.com"
    }
    """;

HttpRequest postRequest = HttpRequest.newBuilder()
    .uri(URI.create("https://httpbin.org/post"))
    .header("Content-Type", "application/json")
    .header("User-Agent", "MyApp/1.0")
    .POST(HttpRequest.BodyPublishers.ofString(json))
    .build();

// MÃºltiplas requisiÃ§Ãµes assÃ­ncronas
List<CompletableFuture<String>> futures = List.of(
    "https://api.github.com/users/octocat",
    "https://api.github.com/users/torvalds",
    "https://api.github.com/users/gvanrossum"
).stream()
.map(url -> HttpRequest.newBuilder().uri(URI.create(url)).build())
.map(req -> client.sendAsync(req, HttpResponse.BodyHandlers.ofString()))
.map(future -> future.thenApply(HttpResponse::body))
.toList();

// Aguardar todas as respostas
CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
    .thenRun(() -> futures.forEach(f -> 
        f.thenAccept(System.out::println)));
```

#### ğŸ“ Upload e Download de Arquivos
```java
// Upload de arquivo
Path uploadFile = Path.of("documento.pdf");
HttpRequest uploadRequest = HttpRequest.newBuilder()
    .uri(URI.create("https://httpbin.org/post"))
    .header("Content-Type", "application/octet-stream")
    .POST(HttpRequest.BodyPublishers.ofFile(uploadFile))
    .build();

// Download para arquivo
HttpRequest downloadRequest = HttpRequest.newBuilder()
    .uri(URI.create("https://httpbin.org/bytes/1024"))
    .build();

HttpResponse<Path> fileResponse = client.send(downloadRequest,
    HttpResponse.BodyHandlers.ofFile(Path.of("downloaded.bin")));

System.out.println("Arquivo salvo em: " + fileResponse.body());
```

ğŸ“š **Saiba mais**: [Java HTTP Client Guide](https://openjdk.org/groups/net/httpclient/intro.html)

---

## ğŸ“ Melhorias em String

### ğŸ”¹ JEP 323: Novos MÃ©todos String

#### â“ O que Ã©?
Adiciona mÃ©todos Ãºteis Ã  classe `String` para operaÃ§Ãµes comuns que antes exigiam cÃ³digo verbose ou bibliotecas externas.

#### âš ï¸ Por que Ã© importante?
Simplifica manipulaÃ§Ã£o de strings e melhora legibilidade do cÃ³digo, especialmente para processamento de texto e validaÃ§Ãµes.

```java
// isBlank() - verifica se string estÃ¡ vazia ou contÃ©m apenas espaÃ§os
String vazia = "";
String espacos = "   ";
String conteudo = "  hello  ";

System.out.println(vazia.isBlank());     // true
System.out.println(espacos.isBlank());   // true
System.out.println(conteudo.isBlank());  // false

// DiferenÃ§a entre isBlank() e isEmpty()
String apenasEspacos = "   ";
System.out.println(apenasEspacos.isEmpty());  // false
System.out.println(apenasEspacos.isBlank());  // true

// lines() - converte string multilinhas em Stream<String>
String multiline = """
    Primeira linha
    Segunda linha
    Terceira linha
    """;

List<String> linhas = multiline.lines()
    .filter(line -> !line.isBlank())
    .map(String::trim)
    .collect(Collectors.toList());

// Processamento de CSV simples
String csv = "JoÃ£o,30,SÃ£o Paulo\nMaria,25,Rio de Janeiro\nPedro,35,Belo Horizonte";
csv.lines()
   .map(line -> line.split(","))
   .forEach(fields -> System.out.printf("Nome: %s, Idade: %s, Cidade: %s%n", 
                                        fields[0], fields[1], fields[2]));

// repeat() - repete string N vezes
String separator = "=".repeat(50);      // 50 caracteres =
String pattern = "Java ".repeat(3);     // "Java Java Java "
String indent = " ".repeat(4);          // 4 espaÃ§os para indentaÃ§Ã£o

// Criando tabelas ASCII simples
System.out.println("+" + "-".repeat(20) + "+");
System.out.println("| " + "Nome".repeat(1) + " ".repeat(15) + "|");
System.out.println("+" + "-".repeat(20) + "+");

// strip(), stripLeading(), stripTrailing() - melhor que trim()
String textoComEspacos = "   hello world   ";
System.out.println("'" + textoComEspacos.strip() + "'");         // 'hello world'
System.out.println("'" + textoComEspacos.stripLeading() + "'");  // 'hello world   '
System.out.println("'" + textoComEspacos.stripTrailing() + "'"); // '   hello world'

// strip() vs trim() - diferenÃ§a com caracteres Unicode
String unicodeSpaces = "\u2000\u2001hello\u2002\u2003";  // Unicode spaces
System.out.println("trim: '" + unicodeSpaces.trim() + "'");      // NÃ£o remove todos
System.out.println("strip: '" + unicodeSpaces.strip() + "'");    // Remove todos
```

#### ğŸ› ï¸ Casos PrÃ¡ticos
```java
// ValidaÃ§Ã£o de formulÃ¡rios
public boolean isValidInput(String input) {
    return input != null && !input.isBlank();
}

// Processamento de logs
public void processLogFile(String logContent) {
    logContent.lines()
        .filter(line -> !line.isBlank())
        .filter(line -> line.contains("ERROR"))
        .forEach(this::handleError);
}

// FormataÃ§Ã£o de output
public void printSection(String title) {
    String border = "=".repeat(title.length() + 4);
    System.out.println(border);
    System.out.println("| " + title + " |");
    System.out.println(border);
}
```

ğŸ“š **Saiba mais**: [String API Enhancements](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html)

---

## ğŸ“ Melhorias em Arquivos

### ğŸ”¹ JEP 323: Files readString() e writeString()

#### â“ O que Ã©?
MÃ©todos convenientes para ler e escrever arquivos de texto completos como String, eliminando boilerplate code.

#### âš ï¸ Por que Ã© importante?
Simplifica drasticamente operaÃ§Ãµes comuns com arquivos de texto, reduzindo cÃ³digo de ~10 linhas para 1 linha.

```java
// Ler arquivo inteiro como String
try {
    String content = Files.readString(Path.of("config.properties"));
    System.out.println(content);
} catch (IOException e) {
    System.err.println("Erro ao ler arquivo: " + e.getMessage());
}

// Escrever String para arquivo
try {
    String config = """
        app.name=MyApplication
        app.version=1.0.0
        app.debug=true
        """;
    
    Files.writeString(Path.of("app.properties"), config);
    System.out.println("Arquivo salvo com sucesso!");
} catch (IOException e) {
    System.err.println("Erro ao escrever arquivo: " + e.getMessage());
}

// Com charset especÃ­fico
Files.writeString(Path.of("utf8-file.txt"), "AcentuaÃ§Ã£o: Ã§Ã£o, Ã£, Ãµ", 
    StandardCharsets.UTF_8);

// Com opÃ§Ãµes de escrita
Files.writeString(
    Path.of("log.txt"), 
    LocalDateTime.now() + ": AplicaÃ§Ã£o iniciada\n",
    StandardCharsets.UTF_8,
    StandardOpenOption.CREATE,
    StandardOpenOption.APPEND
);
```

#### ğŸ”„ Casos PrÃ¡ticos
```java
// ConfiguraÃ§Ã£o simples
public class ConfigManager {
    private final Path configFile = Path.of("app.config");
    
    public void saveConfig(Map<String, String> config) throws IOException {
        String content = config.entrySet().stream()
            .map(entry -> entry.getKey() + "=" + entry.getValue())
            .collect(Collectors.joining("\n"));
        
        Files.writeString(configFile, content);
    }
    
    public Map<String, String> loadConfig() throws IOException {
        return Files.readString(configFile)
            .lines()
            .filter(line -> line.contains("="))
            .map(line -> line.split("=", 2))
            .collect(Collectors.toMap(
                parts -> parts[0].trim(),
                parts -> parts[1].trim()
            ));
    }
}

// Template simples
public String generateHTML(String title, String content) throws IOException {
    String template = Files.readString(Path.of("template.html"));
    return template
        .replace("{{title}}", title)
        .replace("{{content}}", content);
}

// Backup de dados
public void backupData(Object data) throws IOException {
    String json = objectMapper.writeValueAsString(data);
    String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
    Files.writeString(Path.of("backup-" + timestamp + ".json"), json);
}
```

ğŸ“š **Saiba mais**: [Files API Documentation](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/Files.html)

---

## ğŸ”§ Melhorias na Linguagem

### ğŸ”¹ JEP 323: Local-Variable Syntax for Lambda Parameters

#### â“ O que Ã©?
Permite usar `var` em parÃ¢metros de lambda, principalmente para adicionar anotaÃ§Ãµes que antes nÃ£o eram possÃ­veis.

#### âš ï¸ Por que Ã© importante?
Permite anotar parÃ¢metros lambda sem perder a concisÃ£o da inferÃªncia de tipos, Ãºtil para validaÃ§Ã£o e documentaÃ§Ã£o.

```java
// Antes do Java 11 - nÃ£o era possÃ­vel anotar parÃ¢metros lambda inferidos
list.stream()
    .map((@NonNull String s) -> s.toUpperCase())  // âŒ Erro - precisa especificar tipo
    .collect(Collectors.toList());

// Java 11 - usando var para permitir anotaÃ§Ãµes
list.stream()
    .map((@NonNull var s) -> s.toUpperCase())     // âœ… Funciona!
    .collect(Collectors.toList());

// Exemplos prÃ¡ticos com validaÃ§Ã£o
List<String> emails = List.of("user@example.com", "admin@site.org", "invalid-email");

// ValidaÃ§Ã£o com anotaÃ§Ãµes
List<String> validEmails = emails.stream()
    .filter((@Valid var email) -> isValidEmail(email))  // AnotaÃ§Ã£o para ferramentas
    .collect(Collectors.toList());

// MÃºltiplas anotaÃ§Ãµes
BiFunction<String, String, String> concatenator = 
    (@NonNull var first, @NonNull var second) -> first + " " + second;

// AnotaÃ§Ãµes personalizadas para logging/monitoring
list.stream()
    .filter((@Monitored var item) -> item.isActive())
    .map((@Traced var item) -> transform(item))
    .collect(Collectors.toList());
```

#### ğŸ¯ Quando Usar var em Lambdas
```java
// âœ… BOM: Quando precisa de anotaÃ§Ãµes
stream.map((@NonNull var s) -> s.toUpperCase())

// âŒ DESNECESSÃRIO: Quando nÃ£o hÃ¡ anotaÃ§Ãµes
stream.map((var s) -> s.toUpperCase())  // Preferir: s -> s.toUpperCase()

// âœ… BOM: ConsistÃªncia quando alguns parÃ¢metros precisam de anotaÃ§Ã£o
BiFunction<String, String, String> func = 
    (@NonNull var a, var b) -> a + b;  // var em ambos para consistÃªncia
```

ğŸ“š **Saiba mais**: [Lambda Parameter Annotations](https://openjdk.org/jeps/323)

### ğŸ”¹ JEP 330: Launch Single-File Source-Code Programs

#### â“ O que Ã©?
Permite executar arquivos `.java` diretamente sem compilaÃ§Ã£o explÃ­cita, Ãºtil para scripts e prototipagem rÃ¡pida.

#### âš ï¸ Por que Ã© importante?
Torna Java mais acessÃ­vel para scripts e testes rÃ¡pidos, competindo com linguagens interpretadas para tarefas simples.

```java
// Arquivo: Hello.java
public class Hello {
    public static void main(String[] args) {
        if (args.length > 0) {
            System.out.println("Hello, " + args[0] + "!");
        } else {
            System.out.println("Hello, World!");
        }
    }
}
```

```bash
# Executar diretamente (sem javac)
$ java Hello.java
Hello, World!

$ java Hello.java JoÃ£o
Hello, JoÃ£o!

# Com classpaths (se necessÃ¡rio)
$ java -cp libs/*:. Script.java

# Passar propriedades do sistema
$ java -Dapp.env=dev Script.java
```

#### ğŸ› ï¸ Scripts Ãšteis
```java
// Arquivo: WebServer.java - Servidor HTTP simples
import com.sun.net.httpserver.*;
import java.net.InetSocketAddress;
import java.io.IOException;

public class WebServer {
    public static void main(String[] args) throws IOException {
        int port = args.length > 0 ? Integer.parseInt(args[0]) : 8080;
        
        HttpServer server = HttpServer.create(new InetSocketAddress(port), 0);
        server.createContext("/", exchange -> {
            String response = "Hello from Java 11!";
            exchange.sendResponseHeaders(200, response.length());
            exchange.getResponseBody().write(response.getBytes());
            exchange.close();
        });
        
        server.start();
        System.out.println("Server running on http://localhost:" + port);
    }
}

// Executar: java WebServer.java 9000
```

ğŸ“š **Saiba mais**: [Single-File Source-Code Programs](https://openjdk.org/jeps/330)

---

## ğŸ›¡ï¸ Optional Enhancements

### ğŸ”¹ Optional.isEmpty()

#### â“ O que Ã©?
MÃ©todo que verifica se um Optional estÃ¡ vazio, sendo o oposto lÃ³gico de `isPresent()`.

#### âš ï¸ Por que Ã© importante?
Melhora legibilidade do cÃ³digo quando vocÃª quer verificar especificamente se um Optional estÃ¡ vazio.

```java
Optional<String> name = findUserName(userId);

// Antes do Java 11 - nÃ£o muito intuitivo
if (!name.isPresent()) {
    System.out.println("Nome nÃ£o encontrado");
}

// Java 11 - mais claro e direto
if (name.isEmpty()) {
    System.out.println("Nome nÃ£o encontrado");
}

// Casos prÃ¡ticos
public void processUser(Long userId) {
    Optional<User> user = userRepository.findById(userId);
    
    if (user.isEmpty()) {
        throw new UserNotFoundException("User not found: " + userId);
    }
    
    // Processar usuÃ¡rio...
}

// Em streams e validaÃ§Ãµes
List<Optional<String>> optionals = getOptionalValues();
long emptyCount = optionals.stream()
    .filter(Optional::isEmpty)  // Method reference limpo
    .count();

// ValidaÃ§Ã£o de formulÃ¡rio
public boolean hasValidData(UserForm form) {
    return findValidationErrors(form).isEmpty();  // Mais legÃ­vel que !isPresent()
}
```

ğŸ“š **Saiba mais**: [Optional API Documentation](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.html)

---

## ğŸ—‘ï¸ Garbage Collection

### ğŸ”¹ JEP 318: Epsilon Garbage Collector

#### â“ O que Ã©?
Um garbage collector "no-op" que aloca memÃ³ria mas nunca executa coleta, Ãºtil para testes de performance e aplicaÃ§Ãµes de vida curta.

#### âš ï¸ Por que Ã© importante?
Permite medir overhead real do GC, testar aplicaÃ§Ãµes sem GC, e otimizar aplicaÃ§Ãµes de vida muito curta.

```bash
# Ativar Epsilon GC
java -XX:+UnlockExperimentalVMOptions \
     -XX:+UseEpsilonGC \
     MyApplication

# Ãštil para:
# - Benchmarks de performance pura
# - AplicaÃ§Ãµes que fazem pouquÃ­ssimas alocaÃ§Ãµes
# - Testes de vazamento de memÃ³ria
# - MediÃ§Ã£o de overhead do GC

# Exemplo: testar performance sem GC
java -XX:+UnlockExperimentalVMOptions \
     -XX:+UseEpsilonGC \
     -Xmx4g \
     PerformanceTest
```

### ğŸ”¹ JEP 333: ZGC (Experimental)

#### â“ O que Ã©?
Garbage collector experimental focado em baixa latÃªncia, com pause times menores que 10ms independente do tamanho do heap.

#### âš ï¸ Por que Ã© importante?
Permite aplicaÃ§Ãµes com heaps enormes (TBs) mantendo latÃªncia consistentemente baixa, crucial para aplicaÃ§Ãµes real-time.

```bash
# Ativar ZGC (experimental)
java -XX:+UnlockExperimentalVMOptions \
     -XX:+UseZGC \
     -Xmx32g \
     MyLowLatencyApp

# CaracterÃ­sticas do ZGC:
# - Pause times < 10ms
# - Suporta heaps de 8MB a 16TB
# - Colored pointers para operaÃ§Ã£o concorrente
# - Ideal para aplicaÃ§Ãµes de baixa latÃªncia
```

ğŸ“š **Saiba mais**: [ZGC Documentation](https://openjdk.org/jeps/333)

---

## ğŸš€ Performance e JVM

### ğŸ”¹ JEP 328: Flight Recorder

#### â“ O que Ã©?
Torna o Java Flight Recorder (JFR) open source e disponÃ­vel em todas as builds OpenJDK.

#### âš ï¸ Por que Ã© importante?
Oferece profiling de baixo overhead (< 1%) para monitoramento de produÃ§Ã£o e anÃ¡lise de performance.

```bash
# Ativar JFR durante execuÃ§Ã£o
java -XX:+FlightRecorder \
     -XX:StartFlightRecording=duration=60s,filename=app.jfr \
     MyApplication

# Analisar com Java Mission Control
jmc app.jfr

# ConfiguraÃ§Ãµes customizadas
java -XX:+FlightRecorder \
     -XX:FlightRecorderOptions=settings=profile \
     -XX:StartFlightRecording=duration=30m,filename=prod-profile.jfr \
     ProductionApp
```

### ğŸ”¹ JEP 331: Low-Overhead Heap Profiling

#### â“ O que Ã©?
API JVMTI para sampling de alocaÃ§Ãµes de heap com baixo overhead.

#### âš ï¸ Por que Ã© importante?
Permite identificar memory hotspots em produÃ§Ã£o sem impacto significativo na performance.

ğŸ“š **Saiba mais**: [Flight Recorder Guide](https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/)

---

## âŒ RemoÃ§Ãµes e DepreciaÃ§Ãµes

### ğŸ”¹ JEP 320: Remove Java EE and CORBA Modules

#### â“ O que foi removido?
MÃ³dulos Java EE e CORBA que estavam deprecated desde Java 9.

#### âš ï¸ Impacto na migraÃ§Ã£o
AplicaÃ§Ãµes que usavam essas tecnologias precisam adicionar dependÃªncias externas.

```xml
<!-- DependÃªncias necessÃ¡rias se usava Java EE -->
<dependency>
    <groupId>jakarta.xml.bind</groupId>
    <artifactId>jakarta.xml.bind-api</artifactId>
    <version>4.0.0</version>
</dependency>

<dependency>
    <groupId>jakarta.activation</groupId>
    <artifactId>jakarta.activation-api</artifactId>
    <version>2.1.0</version>
</dependency>
```

### ğŸ”¹ JavaFX Separado

#### â“ O que mudou?
JavaFX foi separado do JDK e agora Ã© distribuÃ­do independentemente.

```xml
<!-- JavaFX como dependÃªncia externa -->
<dependency>
    <groupId>org.openjfx</groupId>
    <artifactId>javafx-controls</artifactId>
    <version>19</version>
</dependency>
```

### ğŸ”¹ Nashorn JavaScript Engine Deprecated

#### â“ O que mudou?
Nashorn foi marcado para depreciaÃ§Ã£o, sendo removido no Java 15.

```java
// Deprecated - serÃ¡ removido
ScriptEngine engine = new ScriptEngineManager().getEngineByName("nashorn");

// Alternativa: GraalVM JavaScript engine
```

ğŸ“š **Saiba mais**: [Migration Guide](https://docs.oracle.com/en/java/javase/11/migrate/)

---

## ğŸ¯ Impacto e AdoÃ§Ã£o

Java 11 foi **divisor de Ã¡guas** na histÃ³ria do Java:

- âœ… **Primeira LTS moderna** pÃ³s-Java 8
- âœ… **HTTP Client nativo** eliminou dependÃªncias
- âœ… **APIs simplificadas** (String, Files) melhoraram DX
- âœ… **Performance superior** com novos GCs
- âœ… **RemoÃ§Ã£o de legados** limpou a plataforma
- âœ… **Base sÃ³lida** para versÃµes futuras
- âœ… **Amplamente adotado** pela indÃºstria

---

## ğŸ“… InformaÃ§Ãµes da VersÃ£o

- **ğŸ“… LanÃ§amento**: 25 de setembro de 2018
- **ğŸ”§ Tipo**: LTS (Long Term Support)
- **âš¡ Suporte Oracle**: AtÃ© setembro de 2026 (Extended atÃ© 2032)
- **ğŸ†“ Suporte Gratuito**: Eclipse Temurin, Amazon Corretto, etc.
- **ğŸ¯ Status**: LTS amplamente usado em produÃ§Ã£o
- **ğŸ”„ MigraÃ§Ã£o**: Requer anÃ¡lise de mÃ³dulos removidos

---

## ğŸ”— Links Ãšteis

### ğŸ“š **DocumentaÃ§Ã£o Oficial**
- [Java 11 Documentation](https://docs.oracle.com/en/java/javase/11/)
- [Java 11 API Specification](https://docs.oracle.com/en/java/javase/11/docs/api/)
- [All JEPs in Java 11](https://openjdk.org/projects/jdk/11/)

### ğŸ”„ **MigraÃ§Ã£o**
- [Migration Guide from Java 8](https://docs.oracle.com/en/java/javase/11/migrate/)
- [Removed and Deprecated Features](https://docs.oracle.com/en/java/javase/11/migrate/removed-apis.html)
- [Third-party Replacements](https://stackoverflow.com/questions/43574426/how-to-resolve-java-lang-noclassdeffounderror-javax-xml-bind-jaxbexception)

### ğŸŒ **HTTP Client**
- [HTTP Client Tutorial](https://openjdk.org/groups/net/httpclient/intro.html)
- [HTTP/2 Guide](https://www.baeldung.com/java-9-http-client)
- [Async HTTP Examples](https://mkyong.com/java/java-11-httpclient-examples/)

### ğŸ—‘ï¸ **Garbage Collection**
- [ZGC Documentation](https://wiki.openjdk.org/display/zgc)
- [Epsilon GC Guide](https://openjdk.org/jeps/318)
- [Flight Recorder Tutorial](https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/)

### ğŸ’» **Exemplos e PrÃ¡ticas**
- [Java 11 Features Examples](https://www.baeldung.com/java-11-new-features)
- [Modern Java Development](https://github.com/winterbe/java8-tutorial)
- [Java 11 Migration Checklist](https://blog.codefx.org/java/java-11-migration-guide/) 