# 1Ô∏è‚É£1Ô∏è‚É£ Java 11 LTS (2018)

# üöÄ Java 11 LTS - A Nova Era do Java

## üìñ Sobre o Java 11

Java 11 marcou um **divisor de √°guas** na hist√≥ria do Java, sendo a primeira vers√£o LTS ap√≥s o Java 8. Lan√ßado em setembro de 2018, trouxe mudan√ßas significativas como remo√ß√£o de m√≥dulos legados, APIs modernas e melhorias de performance que definiram o rumo do Java moderno.

## üí° O que s√£o JEPs?
Java 11 incluiu 17 JEPs que modernizaram a plataforma, removeram tecnologias legadas e introduziram APIs que se tornaram essenciais no desenvolvimento Java atual.

---

## üåê APIs de Rede

### üîπ JEP 321: HTTP Client (Standard API)

#### ‚ùì O que √©?
API nativa moderna para requisi√ß√µes HTTP/1.1 e HTTP/2, substituindo a antiga `HttpURLConnection` e eliminando a necessidade de bibliotecas externas como Apache HttpClient.

#### ‚ö†Ô∏è Por que √© importante?
Oferece uma API moderna, ass√≠ncrona e que suporta HTTP/2 out-of-the-box, reduzindo depend√™ncias externas e melhorando performance das aplica√ß√µes.

```java
// HTTP GET b√°sico
HttpClient client = HttpClient.newHttpClient();

HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create("https://api.github.com/users/octocat"))
    .header("Accept", "application/json")
    .timeout(Duration.ofSeconds(10))
    .build();

// S√≠ncrono
HttpResponse<String> response = client.send(request, 
    HttpResponse.BodyHandlers.ofString());

System.out.println("Status: " + response.statusCode());
System.out.println("Body: " + response.body());

// Ass√≠ncrono com CompletableFuture
CompletableFuture<String> asyncResponse = client.sendAsync(request,
    HttpResponse.BodyHandlers.ofString())
    .thenApply(HttpResponse::body);

asyncResponse.thenAccept(System.out::println);
```

#### üöÄ HTTP/2 e Features Avan√ßadas
```java
// Cliente HTTP/2 com configura√ß√£o customizada
HttpClient client = HttpClient.newBuilder()
    .version(HttpClient.Version.HTTP_2)  // Preferir HTTP/2
    .connectTimeout(Duration.ofSeconds(20))
    .followRedirects(HttpClient.Redirect.NORMAL)
    .authenticator(Authenticator.getDefault())
    .build();

// POST com JSON
String json = """
    {
        "name": "Jo√£o Silva",
        "age": 30,
        "email": "joao@example.com"
    }
    """;

HttpRequest postRequest = HttpRequest.newBuilder()
    .uri(URI.create("https://httpbin.org/post"))
    .header("Content-Type", "application/json")
    .header("User-Agent", "MyApp/1.0")
    .POST(HttpRequest.BodyPublishers.ofString(json))
    .build();

// M√∫ltiplas requisi√ß√µes ass√≠ncronas
List<CompletableFuture<String>> futures = List.of(
    "https://api.github.com/users/octocat",
    "https://api.github.com/users/torvalds",
    "https://api.github.com/users/gvanrossum"
).stream()
.map(url -> HttpRequest.newBuilder().uri(URI.create(url)).build())
.map(req -> client.sendAsync(req, HttpResponse.BodyHandlers.ofString()))
.map(future -> future.thenApply(HttpResponse::body))
.toList();

// Aguardar todas as respostas
CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
    .thenRun(() -> futures.forEach(f -> 
        f.thenAccept(System.out::println)));
```

#### üìÅ Upload e Download de Arquivos
```java
// Upload de arquivo
Path uploadFile = Path.of("documento.pdf");
HttpRequest uploadRequest = HttpRequest.newBuilder()
    .uri(URI.create("https://httpbin.org/post"))
    .header("Content-Type", "application/octet-stream")
    .POST(HttpRequest.BodyPublishers.ofFile(uploadFile))
    .build();

// Download para arquivo
HttpRequest downloadRequest = HttpRequest.newBuilder()
    .uri(URI.create("https://httpbin.org/bytes/1024"))
    .build();

HttpResponse<Path> fileResponse = client.send(downloadRequest,
    HttpResponse.BodyHandlers.ofFile(Path.of("downloaded.bin")));

System.out.println("Arquivo salvo em: " + fileResponse.body());
```

üìö **Saiba mais**: [Java HTTP Client Guide](https://openjdk.org/groups/net/httpclient/intro.html)

---

## üìù Melhorias em String

### üîπ JEP 323: Novos M√©todos String

#### ‚ùì O que √©?
Adiciona m√©todos √∫teis √† classe `String` para opera√ß√µes comuns que antes exigiam c√≥digo verbose ou bibliotecas externas.

#### ‚ö†Ô∏è Por que √© importante?
Simplifica manipula√ß√£o de strings e melhora legibilidade do c√≥digo, especialmente para processamento de texto e valida√ß√µes.

```java
// isBlank() - verifica se string est√° vazia ou cont√©m apenas espa√ßos
String vazia = "";
String espacos = "   ";
String conteudo = "  hello  ";

System.out.println(vazia.isBlank());     // true
System.out.println(espacos.isBlank());   // true
System.out.println(conteudo.isBlank());  // false

// Diferen√ßa entre isBlank() e isEmpty()
String apenasEspacos = "   ";
System.out.println(apenasEspacos.isEmpty());  // false
System.out.println(apenasEspacos.isBlank());  // true

// lines() - converte string multilinhas em Stream<String>
String multiline = """
    Primeira linha
    Segunda linha
    Terceira linha
    """;

List<String> linhas = multiline.lines()
    .filter(line -> !line.isBlank())
    .map(String::trim)
    .collect(Collectors.toList());

// Processamento de CSV simples
String csv = "Jo√£o,30,S√£o Paulo\nMaria,25,Rio de Janeiro\nPedro,35,Belo Horizonte";
csv.lines()
   .map(line -> line.split(","))
   .forEach(fields -> System.out.printf("Nome: %s, Idade: %s, Cidade: %s%n", 
                                        fields[0], fields[1], fields[2]));

// repeat() - repete string N vezes
String separator = "=".repeat(50);      // 50 caracteres =
String pattern = "Java ".repeat(3);     // "Java Java Java "
String indent = " ".repeat(4);          // 4 espa√ßos para indenta√ß√£o

// Criando tabelas ASCII simples
System.out.println("+" + "-".repeat(20) + "+");
System.out.println("| " + "Nome".repeat(1) + " ".repeat(15) + "|");
System.out.println("+" + "-".repeat(20) + "+");

// strip(), stripLeading(), stripTrailing() - melhor que trim()
String textoComEspacos = "   hello world   ";
System.out.println("'" + textoComEspacos.strip() + "'");         // 'hello world'
System.out.println("'" + textoComEspacos.stripLeading() + "'");  // 'hello world   '
System.out.println("'" + textoComEspacos.stripTrailing() + "'"); // '   hello world'

// strip() vs trim() - diferen√ßa com caracteres Unicode
String unicodeSpaces = "\u2000\u2001hello\u2002\u2003";  // Unicode spaces
System.out.println("trim: '" + unicodeSpaces.trim() + "'");      // N√£o remove todos
System.out.println("strip: '" + unicodeSpaces.strip() + "'");    // Remove todos
```

#### üõ†Ô∏è Casos Pr√°ticos
```java
// Valida√ß√£o de formul√°rios
public boolean isValidInput(String input) {
    return input != null && !input.isBlank();
}

// Processamento de logs
public void processLogFile(String logContent) {
    logContent.lines()
        .filter(line -> !line.isBlank())
        .filter(line -> line.contains("ERROR"))
        .forEach(this::handleError);
}

// Formata√ß√£o de output
public void printSection(String title) {
    String border = "=".repeat(title.length() + 4);
    System.out.println(border);
    System.out.println("| " + title + " |");
    System.out.println(border);
}
```

üìö **Saiba mais**: [String API Enhancements](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html)

---

## üìÅ Melhorias em Arquivos

### üîπ JEP 323: Files readString() e writeString()

#### ‚ùì O que √©?
M√©todos convenientes para ler e escrever arquivos de texto completos como String, eliminando boilerplate code.

#### ‚ö†Ô∏è Por que √© importante?
Simplifica drasticamente opera√ß√µes comuns com arquivos de texto, reduzindo c√≥digo de ~10 linhas para 1 linha.

```java
// Ler arquivo inteiro como String
try {
    String content = Files.readString(Path.of("config.properties"));
    System.out.println(content);
} catch (IOException e) {
    System.err.println("Erro ao ler arquivo: " + e.getMessage());
}

// Escrever String para arquivo
try {
    String config = """
        app.name=MyApplication
        app.version=1.0.0
        app.debug=true
        """;
    
    Files.writeString(Path.of("app.properties"), config);
    System.out.println("Arquivo salvo com sucesso!");
} catch (IOException e) {
    System.err.println("Erro ao escrever arquivo: " + e.getMessage());
}

// Com charset espec√≠fico
Files.writeString(Path.of("utf8-file.txt"), "Acentua√ß√£o: √ß√£o, √£, √µ", 
    StandardCharsets.UTF_8);

// Com op√ß√µes de escrita
Files.writeString(
    Path.of("log.txt"), 
    LocalDateTime.now() + ": Aplica√ß√£o iniciada\n",
    StandardCharsets.UTF_8,
    StandardOpenOption.CREATE,
    StandardOpenOption.APPEND
);
```

#### üîÑ Casos Pr√°ticos
```java
// Configura√ß√£o simples
public class ConfigManager {
    private final Path configFile = Path.of("app.config");
    
    public void saveConfig(Map<String, String> config) throws IOException {
        String content = config.entrySet().stream()
            .map(entry -> entry.getKey() + "=" + entry.getValue())
            .collect(Collectors.joining("\n"));
        
        Files.writeString(configFile, content);
    }
    
    public Map<String, String> loadConfig() throws IOException {
        return Files.readString(configFile)
            .lines()
            .filter(line -> line.contains("="))
            .map(line -> line.split("=", 2))
            .collect(Collectors.toMap(
                parts -> parts[0].trim(),
                parts -> parts[1].trim()
            ));
    }
}

// Template simples
public String generateHTML(String title, String content) throws IOException {
    String template = Files.readString(Path.of("template.html"));
    return template
        .replace("{{title}}", title)
        .replace("{{content}}", content);
}

// Backup de dados
public void backupData(Object data) throws IOException {
    String json = objectMapper.writeValueAsString(data);
    String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
    Files.writeString(Path.of("backup-" + timestamp + ".json"), json);
}
```

üìö **Saiba mais**: [Files API Documentation](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/Files.html)

---

## üîß Melhorias na Linguagem

### üîπ JEP 323: Local-Variable Syntax for Lambda Parameters

#### ‚ùì O que √©?
Permite usar `var` em par√¢metros de lambda, principalmente para adicionar anota√ß√µes que antes n√£o eram poss√≠veis.

#### ‚ö†Ô∏è Por que √© importante?
Permite anotar par√¢metros lambda sem perder a concis√£o da infer√™ncia de tipos, √∫til para valida√ß√£o e documenta√ß√£o.

```java
// Antes do Java 11 - n√£o era poss√≠vel anotar par√¢metros lambda inferidos
list.stream()
    .map((@NonNull String s) -> s.toUpperCase())  // ‚ùå Erro - precisa especificar tipo
    .collect(Collectors.toList());

// Java 11 - usando var para permitir anota√ß√µes
list.stream()
    .map((@NonNull var s) -> s.toUpperCase())     // ‚úÖ Funciona!
    .collect(Collectors.toList());

// Exemplos pr√°ticos com valida√ß√£o
List<String> emails = List.of("user@example.com", "admin@site.org", "invalid-email");

// Valida√ß√£o com anota√ß√µes
List<String> validEmails = emails.stream()
    .filter((@Valid var email) -> isValidEmail(email))  // Anota√ß√£o para ferramentas
    .collect(Collectors.toList());

// M√∫ltiplas anota√ß√µes
BiFunction<String, String, String> concatenator = 
    (@NonNull var first, @NonNull var second) -> first + " " + second;

// Anota√ß√µes personalizadas para logging/monitoring
list.stream()
    .filter((@Monitored var item) -> item.isActive())
    .map((@Traced var item) -> transform(item))
    .collect(Collectors.toList());
```

#### üéØ Quando Usar var em Lambdas
```java
// ‚úÖ BOM: Quando precisa de anota√ß√µes
stream.map((@NonNull var s) -> s.toUpperCase())

// ‚ùå DESNECESS√ÅRIO: Quando n√£o h√° anota√ß√µes
stream.map((var s) -> s.toUpperCase())  // Preferir: s -> s.toUpperCase()

// ‚úÖ BOM: Consist√™ncia quando alguns par√¢metros precisam de anota√ß√£o
BiFunction<String, String, String> func = 
    (@NonNull var a, var b) -> a + b;  // var em ambos para consist√™ncia
```

üìö **Saiba mais**: [Lambda Parameter Annotations](https://openjdk.org/jeps/323)

### üîπ JEP 330: Launch Single-File Source-Code Programs

#### ‚ùì O que √©?
Permite executar arquivos `.java` diretamente sem compila√ß√£o expl√≠cita, √∫til para scripts e prototipagem r√°pida.

#### ‚ö†Ô∏è Por que √© importante?
Torna Java mais acess√≠vel para scripts e testes r√°pidos, competindo com linguagens interpretadas para tarefas simples.

```java
// Arquivo: Hello.java
public class Hello {
    public static void main(String[] args) {
        if (args.length > 0) {
            System.out.println("Hello, " + args[0] + "!");
        } else {
            System.out.println("Hello, World!");
        }
    }
}
```

```bash
# Executar diretamente (sem javac)
$ java Hello.java
Hello, World!

$ java Hello.java Jo√£o
Hello, Jo√£o!

# Com classpaths (se necess√°rio)
$ java -cp libs/*:. Script.java

# Passar propriedades do sistema
$ java -Dapp.env=dev Script.java
```

#### üõ†Ô∏è Scripts √öteis
```java
// Arquivo: WebServer.java - Servidor HTTP simples
import com.sun.net.httpserver.*;
import java.net.InetSocketAddress;
import java.io.IOException;

public class WebServer {
    public static void main(String[] args) throws IOException {
        int port = args.length > 0 ? Integer.parseInt(args[0]) : 8080;
        
        HttpServer server = HttpServer.create(new InetSocketAddress(port), 0);
        server.createContext("/", exchange -> {
            String response = "Hello from Java 11!";
            exchange.sendResponseHeaders(200, response.length());
            exchange.getResponseBody().write(response.getBytes());
            exchange.close();
        });
        
        server.start();
        System.out.println("Server running on http://localhost:" + port);
    }
}

// Executar: java WebServer.java 9000
```

üìö **Saiba mais**: [Single-File Source-Code Programs](https://openjdk.org/jeps/330)

---

## üõ°Ô∏è Optional Enhancements

### üîπ Optional.isEmpty()

#### ‚ùì O que √©?
M√©todo que verifica se um Optional est√° vazio, sendo o oposto l√≥gico de `isPresent()`.

#### ‚ö†Ô∏è Por que √© importante?
Melhora legibilidade do c√≥digo quando voc√™ quer verificar especificamente se um Optional est√° vazio.

```java
Optional<String> name = findUserName(userId);

// Antes do Java 11 - n√£o muito intuitivo
if (!name.isPresent()) {
    System.out.println("Nome n√£o encontrado");
}

// Java 11 - mais claro e direto
if (name.isEmpty()) {
    System.out.println("Nome n√£o encontrado");
}

// Casos pr√°ticos
public void processUser(Long userId) {
    Optional<User> user = userRepository.findById(userId);
    
    if (user.isEmpty()) {
        throw new UserNotFoundException("User not found: " + userId);
    }
    
    // Processar usu√°rio...
}

// Em streams e valida√ß√µes
List<Optional<String>> optionals = getOptionalValues();
long emptyCount = optionals.stream()
    .filter(Optional::isEmpty)  // Method reference limpo
    .count();

// Valida√ß√£o de formul√°rio
public boolean hasValidData(UserForm form) {
    return findValidationErrors(form).isEmpty();  // Mais leg√≠vel que !isPresent()
}
```

üìö **Saiba mais**: [Optional API Documentation](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.html)

---

## üóëÔ∏è Garbage Collection

### üîπ JEP 318: Epsilon Garbage Collector

#### ‚ùì O que √©?
Um garbage collector "no-op" que aloca mem√≥ria mas nunca executa coleta, √∫til para testes de performance e aplica√ß√µes de vida curta.

#### ‚ö†Ô∏è Por que √© importante?
Permite medir overhead real do GC, testar aplica√ß√µes sem GC, e otimizar aplica√ß√µes de vida muito curta.

```bash
# Ativar Epsilon GC
java -XX:+UnlockExperimentalVMOptions \
     -XX:+UseEpsilonGC \
     MyApplication

# √ötil para:
# - Benchmarks de performance pura
# - Aplica√ß√µes que fazem pouqu√≠ssimas aloca√ß√µes
# - Testes de vazamento de mem√≥ria
# - Medi√ß√£o de overhead do GC

# Exemplo: testar performance sem GC
java -XX:+UnlockExperimentalVMOptions \
     -XX:+UseEpsilonGC \
     -Xmx4g \
     PerformanceTest
```

### üîπ JEP 333: ZGC (Experimental)

#### ‚ùì O que √©?
Garbage collector experimental focado em baixa lat√™ncia, com pause times menores que 10ms independente do tamanho do heap.

#### ‚ö†Ô∏è Por que √© importante?
Permite aplica√ß√µes com heaps enormes (TBs) mantendo lat√™ncia consistentemente baixa, crucial para aplica√ß√µes real-time.

```bash
# Ativar ZGC (experimental)
java -XX:+UnlockExperimentalVMOptions \
     -XX:+UseZGC \
     -Xmx32g \
     MyLowLatencyApp

# Caracter√≠sticas do ZGC:
# - Pause times < 10ms
# - Suporta heaps de 8MB a 16TB
# - Colored pointers para opera√ß√£o concorrente
# - Ideal para aplica√ß√µes de baixa lat√™ncia
```

üìö **Saiba mais**: [ZGC Documentation](https://openjdk.org/jeps/333)

---

## üöÄ Performance e JVM

### üîπ JEP 328: Flight Recorder

#### ‚ùì O que √©?
Torna o Java Flight Recorder (JFR) open source e dispon√≠vel em todas as builds OpenJDK.

#### ‚ö†Ô∏è Por que √© importante?
Oferece profiling de baixo overhead (< 1%) para monitoramento de produ√ß√£o e an√°lise de performance.

```bash
# Ativar JFR durante execu√ß√£o
java -XX:+FlightRecorder \
     -XX:StartFlightRecording=duration=60s,filename=app.jfr \
     MyApplication

# Analisar com Java Mission Control
jmc app.jfr

# Configura√ß√µes customizadas
java -XX:+FlightRecorder \
     -XX:FlightRecorderOptions=settings=profile \
     -XX:StartFlightRecording=duration=30m,filename=prod-profile.jfr \
     ProductionApp
```

### üîπ JEP 331: Low-Overhead Heap Profiling

#### ‚ùì O que √©?
API JVMTI para sampling de aloca√ß√µes de heap com baixo overhead.

#### ‚ö†Ô∏è Por que √© importante?
Permite identificar memory hotspots em produ√ß√£o sem impacto significativo na performance.

üìö **Saiba mais**: [Flight Recorder Guide](https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/)

---

## ‚ùå Remo√ß√µes e Deprecia√ß√µes

### üîπ JEP 320: Remove Java EE and CORBA Modules

#### ‚ùì O que foi removido?
M√≥dulos Java EE e CORBA que estavam deprecated desde Java 9.

#### ‚ö†Ô∏è Impacto na migra√ß√£o
Aplica√ß√µes que usavam essas tecnologias precisam adicionar depend√™ncias externas.

```xml
<!-- Depend√™ncias necess√°rias se usava Java EE -->
<dependency>
    <groupId>jakarta.xml.bind</groupId>
    <artifactId>jakarta.xml.bind-api</artifactId>
    <version>4.0.0</version>
</dependency>

<dependency>
    <groupId>jakarta.activation</groupId>
    <artifactId>jakarta.activation-api</artifactId>
    <version>2.1.0</version>
</dependency>
```

### üîπ JavaFX Separado

#### ‚ùì O que mudou?
JavaFX foi separado do JDK e agora √© distribu√≠do independentemente.

```xml
<!-- JavaFX como depend√™ncia externa -->
<dependency>
    <groupId>org.openjfx</groupId>
    <artifactId>javafx-controls</artifactId>
    <version>19</version>
</dependency>
```

### üîπ Nashorn JavaScript Engine Deprecated

#### ‚ùì O que mudou?
Nashorn foi marcado para deprecia√ß√£o, sendo removido no Java 15.

```java
// Deprecated - ser√° removido
ScriptEngine engine = new ScriptEngineManager().getEngineByName("nashorn");

// Alternativa: GraalVM JavaScript engine
```

üìö **Saiba mais**: [Migration Guide](https://docs.oracle.com/en/java/javase/11/migrate/)

---

## üéØ Impacto e Ado√ß√£o

Java 11 foi **divisor de √°guas** na hist√≥ria do Java:

- ‚úÖ **Primeira LTS moderna** p√≥s-Java 8
- ‚úÖ **HTTP Client nativo** eliminou depend√™ncias
- ‚úÖ **APIs simplificadas** (String, Files) melhoraram DX
- ‚úÖ **Performance superior** com novos GCs
- ‚úÖ **Remo√ß√£o de legados** limpou a plataforma
- ‚úÖ **Base s√≥lida** para vers√µes futuras
- ‚úÖ **Amplamente adotado** pela ind√∫stria

---

## üìÖ Informa√ß√µes da Vers√£o

- **üìÖ Lan√ßamento**: 25 de setembro de 2018
- **üîß Tipo**: LTS (Long Term Support)
- **‚ö° Suporte Oracle**: At√© setembro de 2026 (Extended at√© 2032)
- **üÜì Suporte Gratuito**: Eclipse Temurin, Amazon Corretto, etc.
- **üéØ Status**: LTS amplamente usado em produ√ß√£o
- **üîÑ Migra√ß√£o**: Requer an√°lise de m√≥dulos removidos

---

## üîó Links √öteis

### üìö **Documenta√ß√£o Oficial**
- [Java 11 Documentation](https://docs.oracle.com/en/java/javase/11/)
- [Java 11 API Specification](https://docs.oracle.com/en/java/javase/11/docs/api/)
- [All JEPs in Java 11](https://openjdk.org/projects/jdk/11/)

### üîÑ **Migra√ß√£o**
- [Migration Guide from Java 8](https://docs.oracle.com/en/java/javase/11/migrate/)
- [Removed and Deprecated Features](https://docs.oracle.com/en/java/javase/11/migrate/removed-apis.html)
- [Third-party Replacements](https://stackoverflow.com/questions/43574426/how-to-resolve-java-lang-noclassdeffounderror-javax-xml-bind-jaxbexception)

### üåê **HTTP Client**
- [HTTP Client Tutorial](https://openjdk.org/groups/net/httpclient/intro.html)
- [HTTP/2 Guide](https://www.baeldung.com/java-9-http-client)
- [Async HTTP Examples](https://mkyong.com/java/java-11-httpclient-examples/)

### üóëÔ∏è **Garbage Collection**
- [ZGC Documentation](https://wiki.openjdk.org/display/zgc)
- [Epsilon GC Guide](https://openjdk.org/jeps/318)
- [Flight Recorder Tutorial](https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/)

### üíª **Exemplos e Pr√°ticas**
- [Java 11 Features Examples](https://www.baeldung.com/java-11-new-features)
- [Modern Java Development](https://github.com/winterbe/java8-tutorial)
- [Java 11 Migration Checklist](https://blog.codefx.org/java/java-11-migration-guide/) 