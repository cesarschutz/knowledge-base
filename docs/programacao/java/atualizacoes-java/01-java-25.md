# üìÑ Java 25 LTS (2025)

# üöÄ Java 25 LTS - Guia das Principais Novidades

## üìñ Sobre o Java 25

O Java 25 √© a pr√≥xima vers√£o **LTS (Long-Term Support)** da plataforma Java, com lan√ßamento previsto para **setembro de 2025**. Como vers√£o LTS, receber√° suporte e atualiza√ß√µes por pelo menos 8 anos, tornando-se ideal para aplica√ß√µes empresariais.

## üí° O que s√£o JEPs?
JEPs (Java Enhancement Proposals) s√£o propostas formais de melhorias na plataforma Java. Cada recurso novo passa por fases:
- **Preview**: Dispon√≠vel para testes, pode mudar
- **Incubator**: API experimental
- **Final**: Est√°vel e permanente

---

## ‚≠ê Melhorias na Linguagem

### üîπ JEP 507: Pattern Matching com Tipos Primitivos (Preview)

#### ‚ùì O que √©?
At√© o Java 24, pattern matching funcionava apenas com tipos de refer√™ncia (objetos). Agora, voc√™ pode usar `instanceof` e `switch` diretamente com tipos primitivos como `int`, `double`, etc.

#### ‚ö†Ô∏è Por que √© importante?
Elimina a necessidade de boxing/unboxing manual e torna o c√≥digo mais limpo e intuitivo, especialmente ao trabalhar com APIs que retornam `Object`.

```java
// Antes do Java 25
Object value = getValueFromAPI();
if (value instanceof Integer) {
    Integer i = (Integer) value;
    System.out.println("Valor: " + i);
}

// Java 25 - Direto com primitivos
if (value instanceof int i) {
    System.out.println("Valor: " + i);  // i j√° √© int, n√£o Integer
}

// Switch aprimorado
Object processValue(Object value) {
    return switch (value) {
        case int i when i > 0    -> "Positivo: " + i;
        case int i               -> "Negativo ou zero: " + i;
        case double d            -> "Decimal: " + d;
        case String s            -> "Texto: " + s;
        case null                -> "Valor nulo";
        default                  -> "Tipo n√£o suportado";
    };
}
```

#### üß† Convers√µes Inteligentes
O Java 25 verifica se convers√µes causariam perda de dados:

```java
Object num = 42;
switch (num) {
    case byte b -> // Funciona! 42 cabe em byte (-128 a 127)
        System.out.println("Byte: " + b);
}

Object big = 1000;
switch (big) {
    case byte b -> // N√£o executa - 1000 > 127
        System.out.println("Byte: " + b);
    case int i ->  // Este caso executa
        System.out.println("Int: " + i);
}
```

### üîπ JEP 511: Import de M√≥dulos (Preview)

#### ‚ùì O que √©?
Permite importar todas as classes p√∫blicas de um m√≥dulo com uma √∫nica declara√ß√£o, similar ao `import *` de outras linguagens.

#### ‚ö†Ô∏è Por que √© importante?
Reduz drasticamente o n√∫mero de imports em arquivos Java, especialmente √∫til para prototipagem e scripts.

```java
// Antes - arquivo cheio de imports
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.stream.Stream;
import java.util.stream.Collectors;
// ... pode chegar a 50+ imports

// Java 25 - um √∫nico import de m√≥dulo
import module java.base;

public class DataProcessor {
    // Todas as classes de java.base dispon√≠veis
    Map<String, List<String>> processData(List<String> items) {
        return items.stream()
            .collect(Collectors.groupingBy(s -> s.substring(0, 1)));
    }
}
```

#### ü§ù Resolvendo Conflitos
Quando h√° classes com mesmo nome em m√≥dulos diferentes:

```java
import module java.base;     // cont√©m java.util.List
import module java.desktop;  // cont√©m java.awt.List

// Resolver ambiguidade com import espec√≠fico
import java.util.List;  // Este "ganha"

List<String> strings = new ArrayList<>();  // usa java.util.List
```

### üîπ JEP 512: Arquivos Fonte Compactos (Final)

#### ‚ùì O que √©?
Permite escrever programas Java sem declarar uma classe explicitamente. O compilador cria uma classe impl√≠cita automaticamente.

#### ‚ö†Ô∏è Por que √© importante?
Torna Java mais acess√≠vel para iniciantes e perfeito para scripts simples, competindo com linguagens como Python e JavaScript em simplicidade.

```java
// HelloWorld.java - Sem class, sem public static!
void main() {
    println("Hello, World!");  // println j√° importado
}

// Pode adicionar m√©todos e campos
String nome = "Java 25";
int versao = 25;

void main() {
    println("Bem-vindo ao " + nome);
    mostrarInfo();
}

void mostrarInfo() {
    println("Vers√£o: " + versao);
    var entrada = readln("Digite algo: ");  // readln tamb√©m dispon√≠vel
    println("Voc√™ digitou: " + entrada);
}
```

#### ü§ñ Recursos Autom√°ticos
- Import autom√°tico de `java.io.IO.*` (print, println, readln)
- Import autom√°tico de todo `java.base`
- N√£o precisa de `public`, `static`, ou `String[] args`

### üîπ JEP 513: Construtores Flex√≠veis (Final)

#### ‚ùì O que √©?
Remove a restri√ß√£o de que `super()` ou `this()` deve ser a primeira linha do construtor, permitindo valida√ß√£o e prepara√ß√£o de dados antes.

#### ‚ö†Ô∏è Por que √© importante?
Evita constru√ß√£o de objetos inv√°lidos e permite c√≥digo mais defensivo, especialmente importante em hierarquias de classes.

```java
// Antes do Java 25 - limitado
class Employee extends Person {
    public Employee(String name, int age, String dept) {
        super(name, age);  // DEVE ser primeiro
        // Valida√ß√£o s√≥ depois - tarde demais se super() falhar
        if (age < 18) {
            throw new IllegalArgumentException("Menor de idade");
        }
    }
}

// Java 25 - flex√≠vel e seguro
class Employee extends Person {
    private final String department;
    
    public Employee(String name, int age, String dept) {
        // Validar ANTES de construir
        Objects.requireNonNull(name, "Nome obrigat√≥rio");
        if (age < 18) {
            throw new IllegalArgumentException("Menor de idade");
        }
        
        // Preparar dados
        var normalizedName = name.trim().toUpperCase();
        
        // Agora sim, construir
        super(normalizedName, age);
        this.department = dept;
    }
}
```

---

## üßµ APIs de Concorr√™ncia

### üîπ JEP 506: Scoped Values (Final)

#### ‚ùì O que √©?
Uma alternativa moderna ao `ThreadLocal` que √© mais segura, eficiente e adequada para Virtual Threads. Valores s√£o imut√°veis e automaticamente removidos ao sair do escopo.

#### ‚ö†Ô∏è Por que √© importante?
`ThreadLocal` tem problemas de memory leak e n√£o escala bem com milh√µes de Virtual Threads. Scoped Values resolvem esses problemas.

```java
// Declara√ß√£o
public class SecurityContext {
    static final ScopedValue<User> CURRENT_USER = ScopedValue.newInstance();
    
    // Uso - valor existe apenas dentro do escopo
    public void processRequest(User user, Runnable task) {
        ScopedValue.where(CURRENT_USER, user)
            .run(task);  // user dispon√≠vel durante task
        // user automaticamente removido aqui
    }
    
    // Acesso em qualquer ponto do call stack
    public static void checkPermission(String resource) {
        User user = CURRENT_USER.get();
        if (user == null || !user.hasPermission(resource)) {
            throw new AccessDeniedException();
        }
    }
}
```

#### ‚úÖ Vantagens sobre ThreadLocal
- **Imut√°vel**: N√£o pode ser alterado ap√≥s definido
- **Bounded**: Automaticamente limpo ao sair do escopo
- **Eficiente**: Otimizado para Virtual Threads
- **Seguro**: Sem riscos de vazamento de mem√≥ria

### üîπ JEP 505: Structured Concurrency (5¬∫ Preview)

#### ‚ùì O que √©?
Uma nova forma de trabalhar com m√∫ltiplas threads que as trata como uma unidade estruturada, similar a como tratamos blocos de c√≥digo com try-with-resources.

#### ‚ö†Ô∏è Por que √© importante?
Torna c√≥digo concorrente mais f√°cil de entender e manter, garantindo que threads relacionadas sejam gerenciadas juntas.

```java
// Exemplo b√°sico - buscar dados em paralelo
public UserProfile getUserProfile(Long userId) throws Exception {
    try (var scope = StructuredTaskScope.open()) {
        // Lan√ßar tarefas paralelas
        var userTask = scope.fork(() -> userService.findUser(userId));
        var ordersTask = scope.fork(() -> orderService.findOrders(userId));
        var prefsTask = scope.fork(() -> prefsService.findPreferences(userId));
        
        // Aguardar todas completarem
        scope.join();
        
        // Obter resultados - garantido sem exce√ß√µes perdidas
        return new UserProfile(
            userTask.get(),
            ordersTask.get(),
            prefsTask.get()
        );
    }
    // Qualquer tarefa n√£o finalizada √© cancelada automaticamente
}
```

#### üéØ Pol√≠ticas Especializadas

```java
// ShutdownOnFailure - cancela todas se uma falhar
try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
    var task1 = scope.fork(() -> riskyOperation1());
    var task2 = scope.fork(() -> riskyOperation2());
    
    scope.join()
         .throwIfFailed();  // Lan√ßa exce√ß√£o se alguma falhou
    
    // S√≥ chega aqui se AMBAS tiveram sucesso
    processResults(task1.get(), task2.get());
}

// ShutdownOnSuccess - retorna o primeiro que completar
try (var scope = new StructuredTaskScope.ShutdownOnSuccess<String>()) {
    scope.fork(() -> slowDatabase.query());
    scope.fork(() -> fastCache.get());
    scope.fork(() -> mediumSpeedAPI.fetch());
    
    scope.join();
    
    return scope.result();  // Retorna o mais r√°pido
}
```

### üîπ JEP 502: Stable Value API (Preview)

#### ‚ùì O que √©?
Uma API para valores que s√£o inicializados uma √∫nica vez de forma lazy (pregui√ßosa) e thread-safe, sem necessidade de sincroniza√ß√£o manual.

#### ‚ö†Ô∏è Por que √© importante?
Simplifica padr√µes comuns de inicializa√ß√£o pregui√ßosa, eliminando c√≥digo boilerplate e potenciais bugs de concorr√™ncia.

```java
public class ConfigManager {
    // Valor est√°vel - inicializado uma vez quando necess√°rio
    private final StableValue<Configuration> config = StableValue.of();
    
    public Configuration getConfig() {
        // Inicializa na primeira chamada, retorna o mesmo nas pr√≥ximas
        return config.orElseSet(() -> {
            // C√≥digo de inicializa√ß√£o executado apenas uma vez
            return loadConfigFromFile();
        });
    }
}

// Uso em singleton thread-safe
public class DatabaseConnection {
    private static final StableValue<DatabaseConnection> INSTANCE = StableValue.of();
    
    public static DatabaseConnection getInstance() {
        return INSTANCE.orElseSet(DatabaseConnection::new);
    }
}
```

---

## ‚ö° Performance e Otimiza√ß√µes

### üîπ JEP 508: Vector API (10¬∫ Incubator)

#### ‚ùì O que √©?
API que permite usar instru√ß√µes SIMD (Single Instruction, Multiple Data) do processador para processar m√∫ltiplos dados em paralelo.

#### ‚ö†Ô∏è Por que √© importante?
Oferece ganhos de performance de 5-15x para opera√ß√µes matem√°ticas intensivas, essencial para IA, processamento de imagem e computa√ß√£o cient√≠fica.

```java
// Exemplo: Multiplicar dois arrays
public void multiplyArrays(float[] a, float[] b, float[] result) {
    var species = FloatVector.SPECIES_PREFERRED;
    
    // Loop vetorizado - processa v√°rios elementos por vez
    int i = 0;
    for (; i < species.loopBound(a.length); i += species.length()) {
        FloatVector va = FloatVector.fromArray(species, a, i);
        FloatVector vb = FloatVector.fromArray(species, b, i);
        va.mul(vb).intoArray(result, i);
    }
    
    // Processar elementos restantes
    for (; i < a.length; i++) {
        result[i] = a[i] * b[i];
    }
}
```

#### üé® Casos de Uso
- Machine Learning e IA
- Processamento de imagem e v√≠deo
- Simula√ß√µes cient√≠ficas
- An√°lise de dados em larga escala

### üîπ JEP 521: Shenandoah GC Geracional (Final)

#### ‚ùì O que √©?
O Shenandoah √© um coletor de lixo que trabalha concorrentemente com a aplica√ß√£o. A vers√£o geracional separa objetos jovens e velhos para maior efici√™ncia.

#### ‚ö†Ô∏è Por que √© importante?
Permite pausas extremamente baixas (menor que 5ms) mesmo com heaps enormes (100GB+), ideal para aplica√ß√µes que exigem baixa lat√™ncia.

```bash
# Ativar Shenandoah Geracional
java -XX:+UseShenandoahGC \
     -XX:+ShenandoahGenerational \
     -XX:MaxGCPauseMillis=10 \
     -Xmx32g \
     MyApplication
```

#### üéÅ Benef√≠cios
- Pausas menores que 5ms consistentemente
- Funciona bem com heaps de 1GB a 1TB+
- Ideal para: trading, games, streaming, APIs de baixa lat√™ncia

### üîπ JEP 519: Compact Object Headers (Preview)

#### ‚ùì O que √©?
Reduz o overhead de mem√≥ria de cada objeto Java de 12-16 bytes para apenas 8 bytes.

#### ‚ö†Ô∏è Por que √© importante?
Em aplica√ß√µes com milh√µes de objetos pequenos, pode economizar 20-30% de mem√≥ria.

```bash
# Ativar headers compactos
java -XX:+UseCompactObjectHeaders MyApp

# Exemplo de economia:
# ArrayList com 1M de Integer
# Antes: ~20MB (16 bytes/objeto)
# Depois: ~16MB (8 bytes/objeto)
# Economia: 4MB (20%)
```

---

## üîí Seguran√ßa e Criptografia

### üîπ JEP 510: API de Deriva√ß√£o de Chaves (Final)

#### ‚ùì O que √©?
API nativa para deriva√ß√£o segura de chaves criptogr√°ficas a partir de senhas, incluindo suporte para PBKDF2.

#### ‚ö†Ô∏è Por que √© importante?
Padroniza e simplifica a implementa√ß√£o de autentica√ß√£o segura, seguindo as melhores pr√°ticas da ind√∫stria.

```java
// Criar hash seguro de senha
public byte[] hashPassword(String password, byte[] salt) 
        throws GeneralSecurityException {
    
    SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
    
    PBEKeySpec spec = new PBEKeySpec(
        password.toCharArray(),
        salt,
        120_000,  // itera√ß√µes (OWASP 2024)
        256       // bits de sa√≠da
    );
    
    SecretKey key = factory.generateSecret(spec);
    return key.getEncoded();
}

// Verificar senha
public boolean verifyPassword(String password, byte[] salt, byte[] hash) 
        throws GeneralSecurityException {
    
    byte[] calculatedHash = hashPassword(password, salt);
    return MessageDigest.isEqual(calculatedHash, hash);  // Compara√ß√£o segura
}
```

### üîπ JEP 470: Suporte PEM (Preview)

#### ‚ùì O que √©?
Suporte nativo para ler e escrever certificados e chaves no formato PEM, amplamente usado em HTTPS/TLS.

#### ‚ö†Ô∏è Por que √© importante?
Elimina a necessidade de bibliotecas externas como BouncyCastle para opera√ß√µes b√°sicas com certificados.

```java
// Carregar certificado PEM
CertificateFactory cf = CertificateFactory.getInstance("X.509");
try (var input = Files.newInputStream(Path.of("server.crt"))) {
    X509Certificate cert = (X509Certificate) cf.generateCertificate(input);
}

// Carregar chave privada
KeyFactory kf = KeyFactory.getInstance("RSA");
String pemKey = Files.readString(Path.of("server.key"));
byte[] keyBytes = PEMDecoder.decode(pemKey);  // Nova API
PrivateKey privateKey = kf.generatePrivate(new PKCS8EncodedKeySpec(keyBytes));
```

---

## üîß Mudan√ßas T√©cnicas

### üîπ JEP 503: Remo√ß√£o do Suporte 32-bit

Java 25 suporta apenas sistemas 64-bit. Aplica√ß√µes 32-bit precisam usar Java 21 LTS ou anterior.

### üîπ JEP 509: CPU Profiling Aprimorado (Experimental)

Java Flight Recorder agora oferece profiling de CPU mais detalhado:

```bash
java -XX:StartFlightRecording=cpu-profiling=detailed,filename=profile.jfr MyApp
```

## üîπ Outras Melhorias

- **JEP 514**: CLI simplificada para AOT (Ahead-of-Time compilation)
- **JEP 515**: Profiling por m√©todo em AOT
- **JEP 518**: Sampling cooperativo no JFR
- **JEP 520**: Method-level tracing

---

## üõ†Ô∏è Como Usar

#### üß™ Habilitando Features Preview

```bash
# Compilar com preview
javac --enable-preview --release 25 MyApp.java

# Executar com preview
java --enable-preview MyApp

# Maven
<configuration>
    <release>25</release>
    <compilerArgs>
        <arg>--enable-preview</arg>
    </compilerArgs>
</configuration>
```

#### üî¨ M√≥dulos Incubator

```bash
# Para Vector API
java --add-modules jdk.incubator.vector MyApp
```

---

## üìÖ Cronograma

- **Setembro 2025**: Lan√ßamento Java 25 LTS
- **Suporte at√© 2033+**: M√≠nimo 8 anos de atualiza√ß√µes
- **Pr√≥xima LTS**: Java 29 (2028)

---

## üéØ Resumo

Java 25 representa uma evolu√ß√£o significativa focada em:

1. **Moderniza√ß√£o da Linguagem**: Pattern matching completo, imports simplificados
2. **Produtividade**: Arquivos compactos, construtores flex√≠veis
3. **Concorr√™ncia Moderna**: Scoped Values e Structured Concurrency
4. **Performance**: Vector API, GC aprimorado, headers compactos
5. **Seguran√ßa**: APIs nativas para criptografia moderna

√â a vers√£o LTS ideal para novos projetos e moderniza√ß√£o de aplica√ß√µes existentes.

---

üìö **Para saber mais**: [OpenJDK](https://openjdk.org) | [Inside Java](https://inside.java) | [JEPs](https://openjdk.org/jeps) 