# 8Ô∏è‚É£ Java 8 LTS (2014)

# üöÄ Java 8 LTS - A Revolu√ß√£o Funcional

## üìñ Sobre o Java 8

Java 8 foi **a vers√£o mais transformadora** da hist√≥ria do Java, introduzindo programa√ß√£o funcional e modernizando drasticamente a linguagem. Lan√ßado em mar√ßo de 2014, permanece como uma das vers√µes mais utilizadas em produ√ß√£o at√© hoje.

## üí° O que s√£o JEPs?
JEPs (Java Enhancement Proposals) s√£o propostas formais de melhorias. O Java 8 introduziu v√°rias mudan√ßas fundamentais que definiram o futuro da linguagem.

---

## üéØ Programa√ß√£o Funcional

### üîπ JEP 126: Lambda Expressions

#### ‚ùì O que √©?
Express√µes lambda permitem tratar fun√ß√µes como valores, habilitando programa√ß√£o funcional no Java. √â uma forma concisa de escrever fun√ß√µes an√¥nimas.

#### ‚ö†Ô∏è Por que √© importante?
Revolucionou como escrevemos c√≥digo Java, tornando-o mais conciso, leg√≠vel e expressivo. Eliminou a verbosidade de classes an√¥nimas e abriu caminho para APIs funcionais.

```java
// Antes do Java 8 - Verboso e dif√≠cil de ler
List<String> nomes = Arrays.asList("Ana", "Jo√£o", "Maria", "Pedro");
Collections.sort(nomes, new Comparator<String>() {
    @Override
    public int compare(String a, String b) {
        return a.compareToIgnoreCase(b);
    }
});

// Java 8 - Conciso e claro
Collections.sort(nomes, (a, b) -> a.compareToIgnoreCase(b));

// Ainda mais simples com method reference
Collections.sort(nomes, String::compareToIgnoreCase);

// Exemplos diversos de lambda
Runnable task = () -> System.out.println("Hello World");
Function<String, Integer> stringLength = s -> s.length();
Predicate<String> isEmpty = s -> s.isEmpty();
Consumer<String> printer = System.out::println;
```

#### üß† Sintaxe Lambda
```java
// Sem par√¢metros
() -> System.out.println("Hello")

// Um par√¢metro
x -> x * 2

// M√∫ltiplos par√¢metros
(x, y) -> x + y

// Bloco de c√≥digo
(x, y) -> {
    int sum = x + y;
    return sum * 2;
}
```

üìö **Saiba mais**: [Oracle Lambda Tutorial](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)

### üîπ JEP 107: Method References

#### ‚ùì O que √©?
Sintaxe ainda mais concisa para referenciar m√©todos existentes, usando o operador `::`.

#### ‚ö†Ô∏è Por que √© importante?
Torna o c√≥digo ainda mais limpo quando voc√™ apenas est√° chamando um m√©todo existente, sem adicionar l√≥gica nova.

```java
List<String> nomes = Arrays.asList("ana", "jo√£o", "maria");

// Lambda tradicional
nomes.forEach(nome -> System.out.println(nome));

// Method reference - mais limpo
nomes.forEach(System.out::println);

// Tipos de method references
// 1. M√©todo est√°tico
Function<String, Integer> parser = Integer::parseInt;

// 2. M√©todo de inst√¢ncia de objeto espec√≠fico
String prefix = "Hello ";
Function<String, String> greeter = prefix::concat;

// 3. M√©todo de inst√¢ncia de objeto arbitr√°rio
Function<String, String> upperCase = String::toUpperCase;

// 4. Constructor reference
Supplier<List<String>> listSupplier = ArrayList::new;
Function<String, StringBuilder> sbCreator = StringBuilder::new;
```

---

## üåä Stream API

### üîπ JEP 107: Stream API

#### ‚ùì O que √©?
API para processamento de cole√ß√µes de forma declarativa e funcional, permitindo opera√ß√µes como filter, map, reduce de forma fluente.

#### ‚ö†Ô∏è Por que √© importante?
Revolucionou como processamos dados em Java. C√≥digo mais leg√≠vel, menos propenso a bugs, e com suporte nativo para paraleliza√ß√£o.

```java
List<Person> pessoas = Arrays.asList(
    new Person("Ana", 25, "SP"),
    new Person("Jo√£o", 30, "RJ"), 
    new Person("Maria", 35, "SP"),
    new Person("Pedro", 20, "MG")
);

// Exemplo complexo: Pessoas de SP, maiores de 21, ordenadas por idade
List<String> resultado = pessoas.stream()
    .filter(p -> "SP".equals(p.getEstado()))  // Filtrar por estado
    .filter(p -> p.getIdade() > 21)           // Filtrar por idade
    .sorted(Comparator.comparing(Person::getIdade))  // Ordenar
    .map(Person::getNome)                     // Extrair nome
    .collect(Collectors.toList());            // Coletar resultado

// Opera√ß√µes estat√≠sticas
IntSummaryStatistics stats = pessoas.stream()
    .mapToInt(Person::getIdade)
    .summaryStatistics();

System.out.println("M√©dia de idade: " + stats.getAverage());
System.out.println("Idade m√°xima: " + stats.getMax());
```

#### üöÄ Streams Paralelos
```java
// Processamento paralelo autom√°tico
long count = pessoas.parallelStream()
    .filter(p -> p.getIdade() > 25)
    .count();

// ForkJoinPool √© usado automaticamente
List<String> processedNames = pessoas.parallelStream()
    .map(p -> heavyProcessing(p.getNome()))
    .collect(Collectors.toList());
```

#### üìä Collectors √öteis
```java
// Agrupamento
Map<String, List<Person>> porEstado = pessoas.stream()
    .collect(Collectors.groupingBy(Person::getEstado));

// Particionamento
Map<Boolean, List<Person>> adultos = pessoas.stream()
    .collect(Collectors.partitioningBy(p -> p.getIdade() >= 18));

// String joining
String nomes = pessoas.stream()
    .map(Person::getNome)
    .collect(Collectors.joining(", ", "[", "]"));
```

üìö **Saiba mais**: [Oracle Stream API Guide](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html)

---

## üõ°Ô∏è Programa√ß√£o Defensiva

### üîπ Optional

#### ‚ùì O que √©?
Container que pode ou n√£o conter um valor n√£o-nulo, for√ßando o desenvolvedor a lidar explicitamente com a aus√™ncia de valores.

#### ‚ö†Ô∏è Por que √© importante?
Reduz drasticamente NullPointerExceptions e torna o c√≥digo mais seguro e expressivo. For√ßa tratamento expl√≠cito de casos onde valores podem estar ausentes.

```java
public class UserService {
    // Retorno claro: pode ou n√£o ter usu√°rio
    public Optional<User> findUserById(Long id) {
        User user = database.find(id);
        return Optional.ofNullable(user);
    }
    
    // Uso seguro do Optional
    public String getUserDisplayName(Long id) {
        return findUserById(id)
            .map(User::getName)                    // Se existe, pega nome
            .filter(name -> !name.trim().isEmpty()) // Se n√£o vazio
            .orElse("Usu√°rio An√¥nimo");            // Valor padr√£o
    }
    
    // Opera√ß√µes avan√ßadas
    public void sendNotification(Long userId) {
        findUserById(userId)
            .filter(User::isActive)                // Apenas ativos
            .map(User::getEmail)                   // Pegar email
            .filter(email -> email.contains("@"))  // Validar email
            .ifPresent(this::sendEmail);           // Enviar se v√°lido
    }
}

// Anti-patterns - N√ÉO fa√ßa
// Optional.get() sem verificar - derrota o prop√≥sito
// Optional.of(null) - vai lan√ßar exce√ß√£o
// if (optional.isPresent()) { optional.get() } - use ifPresent()
```

#### üéØ M√©todos √öteis do Optional
```java
Optional<String> opt = Optional.of("Hello");

// Valores padr√£o
opt.orElse("Default");                    // Valor fixo
opt.orElseGet(() -> expensiveCalculation()); // Lazy evaluation
opt.orElseThrow(() -> new RuntimeException()); // Exce√ß√£o customizada

// Transforma√ß√µes
opt.map(String::toUpperCase);             // Transformar se presente
opt.flatMap(this::findRelated);          // Evitar Optional<Optional<T>>
opt.filter(s -> s.length() > 5);         // Filtrar por condi√ß√£o

// A√ß√µes
opt.ifPresent(System.out::println);      // Executar se presente
opt.ifPresentOrElse(                     // Java 9+
    System.out::println,
    () -> System.out.println("Empty")
);
```

üìö **Saiba mais**: [Oracle Optional Guide](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html)

---

## üîß Melhorias em Interfaces

### üîπ Default Methods

#### ‚ùì O que √©?
Permite adicionar m√©todos com implementa√ß√£o padr√£o em interfaces, sem quebrar classes que j√° as implementam.

#### ‚ö†Ô∏è Por que √© importante?
Permite evolu√ß√£o de APIs sem quebrar compatibilidade. Foi essencial para adicionar m√©todos de Stream √† Collection API existente.

```java
public interface Vehicle {
    // M√©todo abstrato tradicional
    void start();
    void stop();
    
    // M√©todo padr√£o - pode ser sobrescrito
    default void honk() {
        System.out.println("Beep beep!");
    }
    
    // M√©todo padr√£o mais complexo
    default String getInfo() {
        return String.format("Vehicle: %s", this.getClass().getSimpleName());
    }
    
    // Pode chamar outros m√©todos
    default void startAndHonk() {
        start();
        honk();
    }
}

public class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("Car engine starting...");
    }
    
    @Override
    public void stop() {
        System.out.println("Car engine stopping...");
    }
    
    // honk() √© herdado automaticamente
    // Pode sobrescrever se necess√°rio
    @Override
    public String getInfo() {
        return "Fast car";
    }
}

// M√∫ltiplas interfaces com default methods
public interface Flyable {
    default void fly() {
        System.out.println("Flying...");
    }
}

public class FlyingCar implements Vehicle, Flyable {
    // Se h√° conflito de nomes, deve resolver explicitamente
    @Override
    public void honk() {
        Vehicle.super.honk(); // Chama implementa√ß√£o espec√≠fica
        System.out.println("Flying car honk!");
    }
}
```

### üîπ Static Methods em Interfaces

#### ‚ùì O que √©?
Permite m√©todos est√°ticos em interfaces, √∫teis para factory methods e utilit√°rios relacionados.

#### ‚ö†Ô∏è Por que √© importante?
Permite agrupar funcionalidades relacionadas na mesma interface, melhorando organiza√ß√£o do c√≥digo.

```java
public interface MathUtils {
    // M√©todos est√°ticos utilit√°rios
    static double pi() {
        return 3.14159265359;
    }
    
    static double circleArea(double radius) {
        return pi() * radius * radius;
    }
    
    // Factory method
    static MathUtils advanced() {
        return new AdvancedMathUtils();
    }
}

// Uso direto
double area = MathUtils.circleArea(5.0);
```

---

## üìÖ Nova API de Data e Hora

### üîπ JSR 310: Date and Time API

#### ‚ùì O que √©?
API completamente nova para trabalhar com datas e hor√°rios, imut√°vel e thread-safe, substituindo as problem√°ticas classes Date e Calendar.

#### ‚ö†Ô∏è Por que √© importante?
As antigas classes Date e Calendar tinham problemas s√©rios: eram mut√°veis, n√£o thread-safe, e confusas. A nova API resolve todos esses problemas.

```java
// Classes principais
LocalDate date = LocalDate.now();              // 2024-01-15
LocalTime time = LocalTime.now();              // 14:30:00
LocalDateTime datetime = LocalDateTime.now();  // 2024-01-15T14:30:00
ZonedDateTime zoned = ZonedDateTime.now();     // 2024-01-15T14:30:00-03:00[America/Sao_Paulo]

// Cria√ß√£o de datas espec√≠ficas
LocalDate birthday = LocalDate.of(1990, Month.DECEMBER, 25);
LocalTime meetingTime = LocalTime.of(14, 30, 0);
LocalDateTime meeting = LocalDateTime.of(2024, 1, 15, 14, 30);

// Opera√ß√µes matem√°ticas - sempre retorna nova inst√¢ncia (imut√°vel)
LocalDate tomorrow = date.plusDays(1);
LocalDate nextWeek = date.plusWeeks(1);
LocalDate nextMonth = date.plusMonths(1);
LocalDate lastYear = date.minusYears(1);

// Formata√ß√£o e parsing
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
String formatted = date.format(formatter);           // "15/01/2024"
LocalDate parsed = LocalDate.parse("25/12/2024", formatter);

// Formata√ß√£o localizada
DateTimeFormatter brFormat = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL)
    .withLocale(new Locale("pt", "BR"));
String brFormatted = date.format(brFormat); // "segunda-feira, 15 de janeiro de 2024"
```

#### üåç Trabalhando com Zonas Hor√°rias
```java
// ZonedDateTime para timestamps precisos
ZoneId saoPaulo = ZoneId.of("America/Sao_Paulo");
ZoneId tokyo = ZoneId.of("Asia/Tokyo");

ZonedDateTime now = ZonedDateTime.now(saoPaulo);
ZonedDateTime tokyoTime = now.withZoneSameInstant(tokyo);

// Per√≠odo e dura√ß√£o
LocalDate start = LocalDate.of(2024, 1, 1);
LocalDate end = LocalDate.of(2024, 12, 31);
Period period = Period.between(start, end);
System.out.println(period.getMonths() + " meses"); // 11 meses

LocalTime startTime = LocalTime.of(9, 0);
LocalTime endTime = LocalTime.of(17, 30);
Duration duration = Duration.between(startTime, endTime);
System.out.println(duration.toHours() + " horas"); // 8 horas
```

#### ‚è∞ Classes Especializadas
```java
// Year, YearMonth para casos espec√≠ficos
Year currentYear = Year.now();
boolean isLeap = currentYear.isLeap();

YearMonth month = YearMonth.of(2024, 2);
int daysInMonth = month.lengthOfMonth(); // 29 (ano bissexto)

// MonthDay para datas recorrentes (anivers√°rios)
MonthDay christmas = MonthDay.of(Month.DECEMBER, 25);
boolean isChristmasToday = christmas.equals(MonthDay.from(LocalDate.now()));

// Instant para timestamps UTC
Instant timestamp = Instant.now();
long epochMilli = timestamp.toEpochMilli();
```

üìö **Saiba mais**: [Oracle Date/Time Tutorial](https://docs.oracle.com/javase/tutorial/datetime/)

---

## üöÄ Performance e JVM

### üîπ Melhorias na JVM

#### **Permanent Generation Removida**
- **Antes**: PermGen causava `OutOfMemoryError: PermGen space`
- **Java 8**: Substitu√≠da por **Metaspace** (mem√≥ria nativa)
- **Benef√≠cio**: Expans√£o autom√°tica, sem mais erros de PermGen

```bash
# Configura√ß√£o antiga (n√£o funciona mais)
# -XX:PermSize=256m -XX:MaxPermSize=512m

# Nova configura√ß√£o
-XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=512m
```

#### **Compact Profiles**
Subconjuntos do JRE para dispositivos com recursos limitados:

```bash
# Profile 1: APIs b√°sicas (~10MB)
# Profile 2: + RMI, XML, etc. (~17MB)  
# Profile 3: + Security, Management (~32MB)
```

### üîπ Nashorn JavaScript Engine

#### ‚ùì O que √©?
Engine JavaScript escrita em Java, substituindo o Rhino, com performance muito superior.

#### ‚ö†Ô∏è Por que √© importante?
Permite executar JavaScript no JVM com performance pr√≥xima ao V8, √∫til para templates e scripting.

```java
ScriptEngineManager manager = new ScriptEngineManager();
ScriptEngine engine = manager.getEngineByName("JavaScript");

// Executar JavaScript
Object result = engine.eval("Math.sqrt(64)");
System.out.println(result); // 8.0

// Passar objetos Java para JavaScript
engine.put("javaObject", new MyClass());
engine.eval("javaObject.method()");
```

üìö **Saiba mais**: [Nashorn Guide](https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/)

---

## üõ†Ô∏è Ferramentas e Utilit√°rios

### üîπ jjs - JavaScript Shell

```bash
# Executar JavaScript
jjs script.js

# REPL interativo
jjs
jjs> print("Hello from Nashorn")
```

### üîπ jdeps - Dependency Analyzer

```bash
# Analisar depend√™ncias de JAR
jdeps myapp.jar

# Verificar depend√™ncias de APIs internas
jdeps -jdkinternals myapp.jar
```

---

## üìà Outras Melhorias Importantes

### üîπ Annotations em Tipos
```java
// Annotations podem ser usadas em qualquer lugar
List<@NonNull String> names;
Map<@NonEmpty String, @Positive Integer> ages;
```

### üîπ Repeating Annotations
```java
@Repeatable(Authors.class)
@interface Author {
    String name();
}

@Author(name = "John")
@Author(name = "Jane") 
public class Book {
    // ...
}
```

### üîπ Base64 API Nativa
```java
// Codificar
String encoded = Base64.getEncoder().encodeToString("Hello".getBytes());

// Decodificar
byte[] decoded = Base64.getDecoder().decode(encoded);
```

---

## üéØ Impacto e Legado

Java 8 foi **a mudan√ßa mais significativa** desde o Java 5:

- ‚úÖ **Programa√ß√£o Funcional** mainstream no Java
- ‚úÖ **C√≥digo mais conciso** e expressivo
- ‚úÖ **Performance melhorada** com Streams paralelos  
- ‚úÖ **Menos bugs** com Optional e imutabilidade
- ‚úÖ **APIs modernas** que influenciaram outras linguagens
- ‚úÖ **Base s√≥lida** para todas as vers√µes futuras

---

## üìÖ Informa√ß√µes da Vers√£o

- **üìÖ Lan√ßamento**: 18 de mar√ßo de 2014
- **üîß Tipo**: LTS (Long Term Support)  
- **‚ö° Suporte Oracle**: At√© janeiro 2019 (p√∫blico)
- **üè¢ Suporte Comercial**: At√© 2030+ (Oracle)
- **üÜì Suporte Gratuito**: Amazon Corretto, Eclipse Temurin
- **üéØ Status**: Ainda amplamente usado em produ√ß√£o

---

## üîó Links √öteis

### üìö **Documenta√ß√£o Oficial**
- [Java 8 Documentation](https://docs.oracle.com/javase/8/)
- [Java 8 API Specification](https://docs.oracle.com/javase/8/docs/api/)
- [JEPs do Java 8](https://openjdk.org/projects/jdk8/)

### üéì **Tutoriais e Guias**
- [Oracle Lambda Tutorial](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)
- [Stream API Guide](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html)
- [Date/Time API Tutorial](https://docs.oracle.com/javase/tutorial/datetime/)
- [Optional Best Practices](https://www.oracle.com/technical-resources/articles/java/java8-optional.html)

### üíª **Exemplos e Pr√°ticas**
- [Java 8 Stream Examples](https://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/)
- [Lambda Expressions Guide](https://www.baeldung.com/java-8-lambda-expressions-tips)
- [Modern Java Best Practices](https://github.com/winterbe/java8-tutorial) 