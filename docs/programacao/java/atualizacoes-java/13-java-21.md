# 2ï¸âƒ£1ï¸âƒ£ Java 21 LTS (2023)

## ğŸš€ Java 21 - A LTS RevolucionÃ¡ria

Java 21 Ã© a versÃ£o LTS mais avanÃ§ada, trazendo Virtual Threads e outras inovaÃ§Ãµes que transformam a programaÃ§Ã£o concorrente em Java.

---

## â­ Principais Novidades

### ğŸ”¹ Virtual Threads (Final)

#### â“ O que Ã©?
Threads leves gerenciadas pela JVM que permitem milhÃµes de threads concorrentes com baixo overhead.

#### ğŸ’¡ Exemplo Simples
```java
// Criar Virtual Thread simples
Thread vThread = Thread.ofVirtual().start(() -> {
    System.out.println("Executando em Virtual Thread: " + 
        Thread.currentThread());
});

// Executor com Virtual Threads
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    // Pode criar milhÃµes dessas sem problema!
    for (int i = 0; i < 100_000; i++) {
        executor.submit(() -> {
            try {
                Thread.sleep(1000); // NÃ£o bloqueia thread do SO
                System.out.println("Task " + Thread.currentThread());
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
    }
}
```

ğŸ“š **Saiba mais**: [Virtual Threads Guide](https://openjdk.org/jeps/444)

### ğŸ”¹ String Templates (Preview)

#### â“ O que Ã©?
InterpolaÃ§Ã£o de strings type-safe que permite embedding de expressÃµes diretamente na string.

#### ğŸ’¡ Exemplo Simples
```java
// String Template bÃ¡sico
String name = "JoÃ£o";
int age = 30;
String message = STR."OlÃ¡, \{name}! VocÃª tem \{age} anos.";
// Resultado: "OlÃ¡, JoÃ£o! VocÃª tem 30 anos."

// Com expressÃµes
double price = 19.99;
int quantity = 3;
String invoice = STR."Total: R$ \{price * quantity}";
// Resultado: "Total: R$ 59.97"

// JSON Template
String json = STR."""
    {
        "name": "\{name}",
        "age": \{age},
        "email": "\{name.toLowerCase()}@email.com"
    }
    """;
```

### ğŸ”¹ Pattern Matching for Switch (Final)

#### â“ O que Ã©?
Switch melhorado que suporta pattern matching com qualquer tipo e guards.

#### ğŸ’¡ Exemplo Simples
```java
// Pattern matching com tipos
public String processValue(Object value) {
    return switch (value) {
        case String s when s.length() > 10 -> "String longa: " + s;
        case String s -> "String curta: " + s;
        case Integer i when i > 0 -> "NÃºmero positivo: " + i;
        case Integer i -> "NÃºmero nÃ£o positivo: " + i;
        case null -> "Valor nulo";
        default -> "Tipo desconhecido: " + value.getClass();
    };
}

// Com Records
record Point(int x, int y) {}
record Circle(Point center, int radius) {}

public String analyzeShape(Object shape) {
    return switch (shape) {
        case Circle(Point(int x, int y), int r) when r > 10 -> 
            STR."CÃ­rculo grande em (\{x}, \{y}) com raio \{r}";
        case Circle(Point(int x, int y), int r) -> 
            STR."CÃ­rculo pequeno em (\{x}, \{y}) com raio \{r}";
        case Point(int x, int y) -> STR."Ponto em (\{x}, \{y})";
        default -> "Forma desconhecida";
    };
}
```

### ğŸ”¹ Sequenced Collections

#### â“ O que Ã©?
Nova interface que representa coleÃ§Ãµes com ordem definida, oferecendo acesso ao primeiro e Ãºltimo elemento.

#### ğŸ’¡ Exemplo Simples
```java
// SequencedCollection interface
List<String> list = List.of("primeiro", "meio", "Ãºltimo");

// MÃ©todos novos
String primeiro = list.getFirst();  // "primeiro"
String ultimo = list.getLast();     // "Ãºltimo"

// Reversed view
List<String> reverso = list.reversed();
// ["Ãºltimo", "meio", "primeiro"]

// Com Set tambÃ©m
LinkedHashSet<String> set = new LinkedHashSet<>();
set.add("a");
set.add("b");
set.add("c");

String primeiroSet = set.getFirst(); // "a"
String ultimoSet = set.getLast();    // "c"
```

### ğŸ”¹ Record Patterns (Final)

#### â“ O que Ã©?
Permite desestruturar Records diretamente em pattern matching.

#### ğŸ’¡ Exemplo Simples
```java
record Person(String name, int age) {}
record Employee(Person person, String department) {}

public String processEmployee(Employee emp) {
    return switch (emp) {
        // DesestruturaÃ§Ã£o aninhada
        case Employee(Person(String name, int age), String dept) 
            when age < 25 -> STR."\{name} Ã© estagiÃ¡rio em \{dept}";
        case Employee(Person(String name, int age), String dept) 
            when age > 50 -> STR."\{name} Ã© sÃªnior em \{dept}";
        case Employee(Person(String name, int age), String dept) -> 
            STR."\{name} (\{age} anos) trabalha em \{dept}";
    };
}
```

### ğŸ”¹ Key Encapsulation Mechanism API

#### â“ O que Ã©?
API para algoritmos criptogrÃ¡ficos quantum-safe, preparando Java para a era pÃ³s-quÃ¢ntica.

#### ğŸ’¡ Exemplo Simples
```java
// Gerar par de chaves para KEM
KeyPairGenerator kpg = KeyPairGenerator.getInstance("ML-KEM");
KeyPair keyPair = kpg.generateKeyPair();

// Encapsular segredo
KEM kem = KEM.getInstance("ML-KEM");
KEM.Encapsulator encapsulator = kem.newEncapsulator(keyPair.getPublic());
KEM.Encapsulated encapsulated = encapsulator.encapsulate();

byte[] sharedSecret = encapsulated.key();
byte[] encapsulation = encapsulated.encapsulation();
```

---

## ğŸ”§ Outras Melhorias Importantes

### âš¡ Performance
- **Generational ZGC**: Garbage Collection ainda mais eficiente
- **Prepare to Restrict Dynamic Loading**: Melhor seguranÃ§a
- **Dynamic CDS Archives**: Startup mais rÃ¡pido

### ğŸ› ï¸ APIs
- **Math.clamp()**: Limitar valores a um range
- **StringBuilder/StringBuffer repeat()**: Repetir sequÃªncias
- **Emoji support**: Melhor suporte a caracteres Unicode

---

## ğŸ¯ Por que Java 21 Ã© RevolucionÃ¡rio?

### ğŸš€ Virtual Threads mudam tudo:
- **MilhÃµes de threads** simultÃ¢neas
- **CÃ³digo simples** para alta concorrÃªncia  
- **Performance excepcional** para I/O
- **CompatÃ­vel** com cÃ³digo existente

### ğŸ¨ Sintaxe Moderna:
- **String Templates** eliminam concatenaÃ§Ã£o
- **Pattern Matching** torna switch poderoso
- **Record Patterns** simplificam desestruturaÃ§Ã£o

### ğŸ” Preparado para o Futuro:
- **Criptografia quantum-safe**
- **APIs modernas e seguras**

---

## ğŸ“… InformaÃ§Ãµes da VersÃ£o

- **ğŸ“… LanÃ§amento**: Setembro de 2023
- **ğŸ”§ Tipo**: LTS (Long Term Support)
- **âš¡ Suporte**: AtÃ© 2031+
- **ğŸ¯ Status**: Nova referÃªncia para projetos modernos

---

## ğŸ”— Links Ãšteis

- [Oracle Java 21 Documentation](https://docs.oracle.com/en/java/javase/21/)
- [Virtual Threads Tutorial](https://www.baeldung.com/java-virtual-thread-vs-thread)
- [Pattern Matching Guide](https://www.baeldung.com/java-pattern-matching-switch)
- [Migration Guide to Java 21](https://docs.oracle.com/en/java/javase/21/migrate/) 