# 2Ô∏è‚É£1Ô∏è‚É£ Java 21 LTS (2023)

# üöÄ Java 21 LTS - A LTS Revolucion√°ria

## üìñ Sobre o Java 21

Java 21 representa um **marco hist√≥rico** na evolu√ß√£o do Java, sendo a vers√£o LTS mais revolucion√°ria desde o Java 8. Lan√ßado em setembro de 2023, introduz **Virtual Threads** como feature final, revolucionando programa√ß√£o concorrente, al√©m de **String Templates**, **Pattern Matching avan√ßado** e **Sequenced Collections**. √â a vers√£o que moderniza definitivamente o desenvolvimento Java para alta performance e concorr√™ncia massiva.

## üí° O que s√£o JEPs?
Java 21 incluiu 15 JEPs que consolidaram anos de desenvolvimento em preview features e introduziram inova√ß√µes que redefinem como escrevemos c√≥digo Java concorrente e expressivo.

---

## ‚≠ê Principais Novidades

## üßµ Concorr√™ncia Revolucion√°ria

### üîπ JEP 444: Virtual Threads (Final)

#### ‚ùì O que √©?
Threads ultra-leves gerenciadas pela JVM que permitem **milh√µes de threads concorrentes** com overhead m√≠nimo, redefinindo completamente programa√ß√£o concorrente em Java.

#### ‚ö†Ô∏è Por que √© importante?
Resolve o problema hist√≥rico do Java com threads caras do SO. Permite escrever c√≥digo sequencial simples que escala para milh√µes de opera√ß√µes concorrentes, especialmente I/O.

```java
// Thread tradicional vs Virtual Thread
// Tradicional: cara, limitada (~thousands)
Thread traditionalThread = new Thread(() -> {
    // Consume ~2MB stack memory
    doWork();
});

// Virtual Thread: barata, ilimitada (millions)
Thread virtualThread = Thread.ofVirtual().start(() -> {
    // Consume ~few KB, managed by JVM
    doWork();
});

// Factory methods para Virtual Threads
Thread vt1 = Thread.ofVirtual()
    .name("worker-1")
    .start(() -> processTask());

Thread vt2 = Thread.ofVirtual()
    .name("worker-", 2)  // worker-2
    .unstarted(() -> processTask());
vt2.start();

// Virtual Thread com Executor
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    // Pode criar MILH√ïES dessas facilmente!
    for (int i = 0; i < 1_000_000; i++) {
        final int taskId = i;
        executor.submit(() -> {
            try {
                // I/O operations n√£o bloqueiam carrier threads
                Thread.sleep(Duration.ofSeconds(1));
                var response = httpClient.send(request, bodyHandler);
                System.out.println("Task " + taskId + " completed");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
    }
} // Executor fecha automaticamente

// Compara√ß√£o de performance
public class PerformanceComparison {
    
    // Approach tradicional - limitado
    public void traditionalApproach() throws InterruptedException {
        var executor = Executors.newFixedThreadPool(200); // M√°ximo pr√°tico
        var latch = new CountDownLatch(10_000);
        
        for (int i = 0; i < 10_000; i++) {
            executor.submit(() -> {
                try {
                    // Simula I/O
                    Thread.sleep(100);
                    latch.countDown();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        latch.await();
        executor.shutdown();
    }
    
    // Virtual Threads - escala infinitamente
    public void virtualThreadsApproach() throws InterruptedException {
        var latch = new CountDownLatch(1_000_000); // 100x mais!
        
        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            for (int i = 0; i < 1_000_000; i++) {
                executor.submit(() -> {
                    try {
                        // Mesmo I/O, mas n√£o bloqueia carrier threads
                        Thread.sleep(100);
                        latch.countDown();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                });
            }
        }
        
        latch.await(); // Roda muito mais r√°pido!
    }
}
```

#### üåê Casos de Uso Pr√°ticos

```java
// Web Server com alta concorr√™ncia
public class HighConcurrencyWebServer {
    
    public void handleRequests() {
        var server = HttpServer.create();
        
        server.createContext("/api", exchange -> {
            // Cada request roda em sua pr√≥pria Virtual Thread
            Thread.ofVirtual().start(() -> {
                try {
                    // I/O intensivo n√£o bloqueia outras requests
                    var data = fetchFromDatabase();
                    var enriched = callExternalAPI(data);
                    var response = processData(enriched);
                    
                    exchange.sendResponseHeaders(200, response.length());
                    exchange.getResponseBody().write(response.getBytes());
                    exchange.close();
                } catch (Exception e) {
                    handleError(exchange, e);
                }
            });
        });
    }
    
    // Web Scraping massivo
    public List<String> scrapeUrls(List<String> urls) {
        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            var futures = urls.stream()
                .map(url -> executor.submit(() -> {
                    // Milhares de requests HTTP concorrentes
                    return httpClient.send(
                        HttpRequest.newBuilder(URI.create(url)).build(),
                        HttpResponse.BodyHandlers.ofString()
                    ).body();
                }))
                .toList();
            
            // Aguardar todos completarem
            return futures.stream()
                .map(future -> {
                    try { return future.get(); }
                    catch (Exception e) { return "Error: " + e.getMessage(); }
                })
                .toList();
        }
    }
    
    // Processamento de arquivos em lote
    public void processLargeDataset(List<Path> files) {
        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            var tasks = files.stream()
                .map(file -> executor.submit(() -> {
                    try {
                        // I/O de arquivo n√£o bloqueia
                        var content = Files.readString(file);
                        var processed = processContent(content);
                        var outputFile = generateOutputPath(file);
                        Files.writeString(outputFile, processed);
                        return outputFile;
                    } catch (IOException e) {
                        throw new UncheckedIOException(e);
                    }
                }))
                .toList();
            
            // Aguardar processamento
            tasks.forEach(task -> {
                try { 
                    var result = task.get();
                    System.out.println("Processed: " + result);
                } catch (Exception e) {
                    System.err.println("Error: " + e.getMessage());
                }
            });
        }
    }
}
```

#### ‚ö° Performance e Caracter√≠sticas

| Aspecto | Platform Threads | Virtual Threads |
|---------|------------------|-----------------|
| **Mem√≥ria Stack** | ~2MB cada | ~few KB cada |
| **Limite Pr√°tico** | ~thousands | **millions** |
| **Cria√ß√£o** | Cara (~1ms) | **Muito barata (~Œºs)** |
| **Context Switch** | Caro (kernel) | **Muito barato (JVM)** |
| **I/O Blocking** | Bloqueia thread | **N√£o bloqueia carrier** |
| **Compatibilidade** | C√≥digo existente | **100% compat√≠vel** |

üìö **Saiba mais**: [Virtual Threads Guide](https://openjdk.org/jeps/444)

## üé® String Templates

### üîπ JEP 430: String Templates (Preview)

#### ‚ùì O que √©?
Sistema type-safe de interpola√ß√£o de strings que permite embedding seguro de express√µes e valores diretamente na string, substituindo concatena√ß√£o verbosa.

#### ‚ö†Ô∏è Por que √© importante?
Elimina problemas de SQL injection, oferece melhor performance que concatena√ß√£o e torna c√≥digo mais leg√≠vel e seguro.

```java
// String Template b√°sico
String name = "Jo√£o Silva";
int age = 30;
String message = STR."Ol√°, \{name}! Voc√™ tem \{age} anos.";
// Resultado: "Ol√°, Jo√£o Silva! Voc√™ tem 30 anos."

// Express√µes complexas
double price = 19.99;
int quantity = 3;
double tax = 0.08;
String invoice = STR."Total: R$ \{price * quantity * (1 + tax):%.2f}";
// Resultado: "Total: R$ 64.77"

// Templates multilinhas
String report = STR."""
    Relat√≥rio de Vendas
    ==================
    Cliente: \{name}
    Idade: \{age} anos
    Itens: \{quantity}
    Subtotal: R$ \{price * quantity:%.2f}
    Taxa: R$ \{price * quantity * tax:%.2f}
    Total: R$ \{price * quantity * (1 + tax):%.2f}
    Data: \{LocalDateTime.now().format(DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm"))}
    """;

// Templates para diferentes formatos
public class TemplateExamples {
    
    // JSON seguro
    public String generateJson(User user) {
        return STR."""
            {
                "id": \{user.getId()},
                "name": "\{user.getName()}",
                "email": "\{user.getEmail()}",
                "active": \{user.isActive()},
                "lastLogin": "\{user.getLastLogin()?.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)}",
                "roles": [\{user.getRoles().stream()
                    .map(role -> STR."\"\{role}\"")
                    .collect(Collectors.joining(", "))}]
            }
            """;
    }
    
    // SQL Templates (type-safe!)
    public String buildQuery(String table, List<String> columns, Map<String, Object> filters) {
        var columnList = String.join(", ", columns);
        var whereClause = filters.entrySet().stream()
            .map(entry -> STR."\{entry.getKey()} = ?\{entry.getValue()}")
            .collect(Collectors.joining(" AND "));
            
        return STR."""
            SELECT \{columnList}
            FROM \{table}
            WHERE \{whereClause}
            ORDER BY created_at DESC
            """;
    }
    
    // HTML Templates
    public String generateCard(Product product) {
        return STR."""
            <div class="product-card">
                <h3>\{product.getName()}</h3>
                <p class="description">\{product.getDescription()}</p>
                <div class="price">
                    <span class="currency">R$</span>
                    <span class="amount">\{product.getPrice():%.2f}</span>
                </div>
                <div class="stock \{product.getStock() > 0 ? "in-stock" : "out-of-stock"}">
                    \{product.getStock() > 0 ? 
                        STR."\{product.getStock()} dispon√≠veis" : 
                        "Fora de estoque"}
                </div>
            </div>
            """;
    }
}
```

#### üõ°Ô∏è Templates Customizados

```java
// Template processor customizado para SQL
public static final StringTemplate.Processor<PreparedStatement, SQLException> SQL = 
    (StringTemplate template) -> {
        String query = StringTemplate.STR.process(template);
        return connection.prepareStatement(query);
    };

// Uso seguro contra SQL injection
public List<User> findUsers(String namePattern, int minAge) throws SQLException {
    PreparedStatement stmt = SQL."""
        SELECT * FROM users 
        WHERE name LIKE \{namePattern}
        AND age >= \{minAge}
        ORDER BY name
        """;
    
    // PreparedStatement j√° configurado!
    return executeQuery(stmt);
}

// Template para logs estruturados
public static final StringTemplate.Processor<LogEvent, RuntimeException> LOG = 
    (StringTemplate template) -> {
        // Processa template e cria evento de log estruturado
        var processed = StringTemplate.STR.process(template);
        return new LogEvent(Level.INFO, processed, Instant.now());
    };

// Uso
LogEvent event = LOG."User \{userId} performed action \{action} at \{timestamp}";
logger.log(event);
```

### üîπ Pattern Matching for Switch (Final)

#### ‚ùì O que √©?
Switch melhorado que suporta pattern matching com qualquer tipo e guards.

#### üí° Exemplo Simples
```java
// Pattern matching com tipos
public String processValue(Object value) {
    return switch (value) {
        case String s when s.length() > 10 -> "String longa: " + s;
        case String s -> "String curta: " + s;
        case Integer i when i > 0 -> "N√∫mero positivo: " + i;
        case Integer i -> "N√∫mero n√£o positivo: " + i;
        case null -> "Valor nulo";
        default -> "Tipo desconhecido: " + value.getClass();
    };
}

// Com Records
record Point(int x, int y) {}
record Circle(Point center, int radius) {}

public String analyzeShape(Object shape) {
    return switch (shape) {
        case Circle(Point(int x, int y), int r) when r > 10 -> 
            STR."C√≠rculo grande em (\{x}, \{y}) com raio \{r}";
        case Circle(Point(int x, int y), int r) -> 
            STR."C√≠rculo pequeno em (\{x}, \{y}) com raio \{r}";
        case Point(int x, int y) -> STR."Ponto em (\{x}, \{y})";
        default -> "Forma desconhecida";
    };
}
```

### üîπ Sequenced Collections

#### ‚ùì O que √©?
Nova interface que representa cole√ß√µes com ordem definida, oferecendo acesso ao primeiro e √∫ltimo elemento.

#### üí° Exemplo Simples
```java
// SequencedCollection interface
List<String> list = List.of("primeiro", "meio", "√∫ltimo");

// M√©todos novos
String primeiro = list.getFirst();  // "primeiro"
String ultimo = list.getLast();     // "√∫ltimo"

// Reversed view
List<String> reverso = list.reversed();
// ["√∫ltimo", "meio", "primeiro"]

// Com Set tamb√©m
LinkedHashSet<String> set = new LinkedHashSet<>();
set.add("a");
set.add("b");
set.add("c");

String primeiroSet = set.getFirst(); // "a"
String ultimoSet = set.getLast();    // "c"
```

### üîπ Record Patterns (Final)

#### ‚ùì O que √©?
Permite desestruturar Records diretamente em pattern matching.

#### üí° Exemplo Simples
```java
record Person(String name, int age) {}
record Employee(Person person, String department) {}

public String processEmployee(Employee emp) {
    return switch (emp) {
        // Desestrutura√ß√£o aninhada
        case Employee(Person(String name, int age), String dept) 
            when age < 25 -> STR."\{name} √© estagi√°rio em \{dept}";
        case Employee(Person(String name, int age), String dept) 
            when age > 50 -> STR."\{name} √© s√™nior em \{dept}";
        case Employee(Person(String name, int age), String dept) -> 
            STR."\{name} (\{age} anos) trabalha em \{dept}";
    };
}
```

### üîπ Key Encapsulation Mechanism API

#### ‚ùì O que √©?
API para algoritmos criptogr√°ficos quantum-safe, preparando Java para a era p√≥s-qu√¢ntica.

#### üí° Exemplo Simples
```java
// Gerar par de chaves para KEM
KeyPairGenerator kpg = KeyPairGenerator.getInstance("ML-KEM");
KeyPair keyPair = kpg.generateKeyPair();

// Encapsular segredo
KEM kem = KEM.getInstance("ML-KEM");
KEM.Encapsulator encapsulator = kem.newEncapsulator(keyPair.getPublic());
KEM.Encapsulated encapsulated = encapsulator.encapsulate();

byte[] sharedSecret = encapsulated.key();
byte[] encapsulation = encapsulated.encapsulation();
```

---

## üîß Outras Melhorias Importantes

### ‚ö° Performance
- **Generational ZGC**: Garbage Collection ainda mais eficiente
- **Prepare to Restrict Dynamic Loading**: Melhor seguran√ßa
- **Dynamic CDS Archives**: Startup mais r√°pido

### üõ†Ô∏è APIs
- **Math.clamp()**: Limitar valores a um range
- **StringBuilder/StringBuffer repeat()**: Repetir sequ√™ncias
- **Emoji support**: Melhor suporte a caracteres Unicode

---

---

## üéØ Impacto e Revolu√ß√£o

Java 21 representa **a maior revolu√ß√£o** desde Java 8:

- ‚úÖ **Virtual Threads** eliminam limita√ß√µes de concorr√™ncia
- ‚úÖ **String Templates** modernizam manipula√ß√£o de strings
- ‚úÖ **Pattern Matching avan√ßado** simplifica l√≥gica complexa
- ‚úÖ **Sequenced Collections** melhoram APIs de cole√ß√£o
- ‚úÖ **Performance excepcional** para aplica√ß√µes I/O intensivas
- ‚úÖ **Preparado para futuro** quantum-safe
- ‚úÖ **Compatibilidade total** com c√≥digo existente

## üìä Compara√ß√£o de LTS

| Aspecto | Java 8 | Java 11 | Java 17 | **Java 21** |
|---------|---------|---------|---------|-------------|
| **Concorr√™ncia** | Threads tradicionais | Threads tradicionais | Threads tradicionais | **üöÄ Virtual Threads** |
| **String Templates** | ‚ùå | ‚ùå | ‚ùå | **‚úÖ Preview** |
| **Pattern Matching** | ‚ùå | ‚ùå | instanceof | **‚úÖ Switch avan√ßado** |
| **Record Patterns** | ‚ùå | ‚ùå | ‚ùå | **‚úÖ Final** |
| **Sequenced Collections** | ‚ùå | ‚ùå | ‚ùå | **‚úÖ Final** |
| **Quantum-safe Crypto** | ‚ùå | ‚ùå | ‚ùå | **‚úÖ KEM API** |
| **Performance I/O** | Thread pools | Thread pools | Thread pools | **üöÄ Massivamente escal√°vel** |

---

## üìÖ Informa√ß√µes da Vers√£o

- **üìÖ Lan√ßamento**: 19 de setembro de 2023
- **üîß Tipo**: LTS (Long Term Support)
- **‚ö° Suporte Oracle**: At√© setembro de 2031 (Extended at√© 2034)
- **üÜì Suporte Gratuito**: Eclipse Temurin, Amazon Corretto, Microsoft OpenJDK
- **üéØ Status**: **LTS revolucion√°ria** - nova refer√™ncia para alta performance
- **üîÑ Migra√ß√£o**: F√°cil - principalmente additive features

---

## üîó Links √öteis

### üìö **Documenta√ß√£o Oficial**
- [Java 21 Documentation](https://docs.oracle.com/en/java/javase/21/)
- [Java 21 API Specification](https://docs.oracle.com/en/java/javase/21/docs/api/)
- [All JEPs in Java 21](https://openjdk.org/projects/jdk/21/)

### üßµ **Virtual Threads**
- [Virtual Threads Guide](https://openjdk.org/jeps/444)
- [Virtual Threads Tutorial](https://www.baeldung.com/java-virtual-thread-vs-thread)
- [Loom Project](https://openjdk.org/projects/loom/)
- [Virtual Threads Best Practices](https://spring.io/blog/2022/10/11/embracing-virtual-threads)

### üé® **String Templates**
- [String Templates JEP](https://openjdk.org/jeps/430)
- [String Interpolation Guide](https://www.baeldung.com/java-string-templates)

### üîç **Pattern Matching**
- [Pattern Matching for Switch](https://openjdk.org/jeps/441)
- [Record Patterns](https://openjdk.org/jeps/440)
- [Pattern Matching Tutorial](https://www.baeldung.com/java-pattern-matching-switch)

### üìö **Collections**
- [Sequenced Collections](https://openjdk.org/jeps/431)
- [Collections Framework](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/doc-files/coll-overview.html)

### üîí **Seguran√ßa**
- [Key Encapsulation Mechanism](https://openjdk.org/jeps/452)
- [Quantum-Safe Cryptography](https://www.nist.gov/news-events/news/2022/07/nist-announces-first-four-quantum-resistant-cryptographic-algorithms)

### üíª **Exemplos e Pr√°ticas**
- [Java 21 Features Examples](https://www.baeldung.com/java-21-new-features)
- [Modern Java Development](https://github.com/openjdk/jdk21)
- [Virtual Threads Cookbook](https://github.com/ebarlas/virtual-threads-examples) 