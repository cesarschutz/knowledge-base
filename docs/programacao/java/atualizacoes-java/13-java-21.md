# 2ï¸âƒ£1ï¸âƒ£ Java 21 LTS (2023)

# ğŸš€ Java 21 LTS - A LTS RevolucionÃ¡ria

## ğŸ“– Sobre o Java 21

Java 21 representa um **marco histÃ³rico** na evoluÃ§Ã£o do Java, sendo a versÃ£o LTS mais revolucionÃ¡ria desde o Java 8. LanÃ§ado em setembro de 2023, introduz **Virtual Threads** como feature final, revolucionando programaÃ§Ã£o concorrente, alÃ©m de **String Templates**, **Pattern Matching avanÃ§ado** e **Sequenced Collections**. Ã‰ a versÃ£o que moderniza definitivamente o desenvolvimento Java para alta performance e concorrÃªncia massiva.

## ğŸ’¡ O que sÃ£o JEPs?
Java 21 incluiu 15 JEPs que consolidaram anos de desenvolvimento em preview features e introduziram inovaÃ§Ãµes que redefinem como escrevemos cÃ³digo Java concorrente e expressivo.

---

## â­ Principais Novidades

## ğŸ§µ ConcorrÃªncia RevolucionÃ¡ria

### ğŸ”¹ JEP 444: Virtual Threads (Final)

#### â“ O que Ã©?
Threads ultra-leves gerenciadas pela JVM que permitem **milhÃµes de threads concorrentes** com overhead mÃ­nimo, redefinindo completamente programaÃ§Ã£o concorrente em Java.

#### âš ï¸ Por que Ã© importante?
Resolve o problema histÃ³rico do Java com threads caras do SO. Permite escrever cÃ³digo sequencial simples que escala para milhÃµes de operaÃ§Ãµes concorrentes, especialmente I/O.

```java
// Thread tradicional vs Virtual Thread
// Tradicional: cara, limitada (~thousands)
Thread traditionalThread = new Thread(() -> {
    // Consume ~2MB stack memory
    doWork();
});

// Virtual Thread: barata, ilimitada (millions)
Thread virtualThread = Thread.ofVirtual().start(() -> {
    // Consume ~few KB, managed by JVM
    doWork();
});

// Factory methods para Virtual Threads
Thread vt1 = Thread.ofVirtual()
    .name("worker-1")
    .start(() -> processTask());

Thread vt2 = Thread.ofVirtual()
    .name("worker-", 2)  // worker-2
    .unstarted(() -> processTask());
vt2.start();

// Virtual Thread com Executor
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    // Pode criar MILHÃ•ES dessas facilmente!
    for (int i = 0; i < 1_000_000; i++) {
        final int taskId = i;
        executor.submit(() -> {
            try {
                // I/O operations nÃ£o bloqueiam carrier threads
                Thread.sleep(Duration.ofSeconds(1));
                var response = httpClient.send(request, bodyHandler);
                System.out.println("Task " + taskId + " completed");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
    }
} // Executor fecha automaticamente

// ComparaÃ§Ã£o de performance
public class PerformanceComparison {
    
    // Approach tradicional - limitado
    public void traditionalApproach() throws InterruptedException {
        var executor = Executors.newFixedThreadPool(200); // MÃ¡ximo prÃ¡tico
        var latch = new CountDownLatch(10_000);
        
        for (int i = 0; i < 10_000; i++) {
            executor.submit(() -> {
                try {
                    // Simula I/O
                    Thread.sleep(100);
                    latch.countDown();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        latch.await();
        executor.shutdown();
    }
    
    // Virtual Threads - escala infinitamente
    public void virtualThreadsApproach() throws InterruptedException {
        var latch = new CountDownLatch(1_000_000); // 100x mais!
        
        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            for (int i = 0; i < 1_000_000; i++) {
                executor.submit(() -> {
                    try {
                        // Mesmo I/O, mas nÃ£o bloqueia carrier threads
                        Thread.sleep(100);
                        latch.countDown();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                });
            }
        }
        
        latch.await(); // Roda muito mais rÃ¡pido!
    }
}
```

#### ğŸŒ Casos de Uso PrÃ¡ticos

```java
// Web Server com alta concorrÃªncia
public class HighConcurrencyWebServer {
    
    public void handleRequests() {
        var server = HttpServer.create();
        
        server.createContext("/api", exchange -> {
            // Cada request roda em sua prÃ³pria Virtual Thread
            Thread.ofVirtual().start(() -> {
                try {
                    // I/O intensivo nÃ£o bloqueia outras requests
                    var data = fetchFromDatabase();
                    var enriched = callExternalAPI(data);
                    var response = processData(enriched);
                    
                    exchange.sendResponseHeaders(200, response.length());
                    exchange.getResponseBody().write(response.getBytes());
                    exchange.close();
                } catch (Exception e) {
                    handleError(exchange, e);
                }
            });
        });
    }
    
    // Web Scraping massivo
    public List<String> scrapeUrls(List<String> urls) {
        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            var futures = urls.stream()
                .map(url -> executor.submit(() -> {
                    // Milhares de requests HTTP concorrentes
                    return httpClient.send(
                        HttpRequest.newBuilder(URI.create(url)).build(),
                        HttpResponse.BodyHandlers.ofString()
                    ).body();
                }))
                .toList();
            
            // Aguardar todos completarem
            return futures.stream()
                .map(future -> {
                    try { return future.get(); }
                    catch (Exception e) { return "Error: " + e.getMessage(); }
                })
                .toList();
        }
    }
    
    // Processamento de arquivos em lote
    public void processLargeDataset(List<Path> files) {
        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            var tasks = files.stream()
                .map(file -> executor.submit(() -> {
                    try {
                        // I/O de arquivo nÃ£o bloqueia
                        var content = Files.readString(file);
                        var processed = processContent(content);
                        var outputFile = generateOutputPath(file);
                        Files.writeString(outputFile, processed);
                        return outputFile;
                    } catch (IOException e) {
                        throw new UncheckedIOException(e);
                    }
                }))
                .toList();
            
            // Aguardar processamento
            tasks.forEach(task -> {
                try { 
                    var result = task.get();
                    System.out.println("Processed: " + result);
                } catch (Exception e) {
                    System.err.println("Error: " + e.getMessage());
                }
            });
        }
    }
}
```

#### âš¡ Performance e CaracterÃ­sticas

| Aspecto | Platform Threads | Virtual Threads |
|---------|------------------|-----------------|
| **MemÃ³ria Stack** | ~2MB cada | ~few KB cada |
| **Limite PrÃ¡tico** | ~thousands | **millions** |
| **CriaÃ§Ã£o** | Cara (~1ms) | **Muito barata (~Î¼s)** |
| **Context Switch** | Caro (kernel) | **Muito barato (JVM)** |
| **I/O Blocking** | Bloqueia thread | **NÃ£o bloqueia carrier** |
| **Compatibilidade** | CÃ³digo existente | **100% compatÃ­vel** |

ğŸ“š **Saiba mais**: [Virtual Threads Guide](https://openjdk.org/jeps/444)

## ğŸ¨ String Templates

### ğŸ”¹ JEP 430: String Templates (Preview)

#### â“ O que Ã©?
Sistema type-safe de interpolaÃ§Ã£o de strings que permite embedding seguro de expressÃµes e valores diretamente na string, substituindo concatenaÃ§Ã£o verbosa.

#### âš ï¸ Por que Ã© importante?
Elimina problemas de SQL injection, oferece melhor performance que concatenaÃ§Ã£o e torna cÃ³digo mais legÃ­vel e seguro.

```java
// String Template bÃ¡sico
String name = "JoÃ£o Silva";
int age = 30;
String message = STR."OlÃ¡, \{name}! VocÃª tem \{age} anos.";
// Resultado: "OlÃ¡, JoÃ£o Silva! VocÃª tem 30 anos."

// ExpressÃµes complexas
double price = 19.99;
int quantity = 3;
double tax = 0.08;
String invoice = STR."Total: R$ \{price * quantity * (1 + tax):%.2f}";
// Resultado: "Total: R$ 64.77"

// Templates multilinhas
String report = STR."""
    RelatÃ³rio de Vendas
    ==================
    Cliente: \{name}
    Idade: \{age} anos
    Itens: \{quantity}
    Subtotal: R$ \{price * quantity:%.2f}
    Taxa: R$ \{price * quantity * tax:%.2f}
    Total: R$ \{price * quantity * (1 + tax):%.2f}
    Data: \{LocalDateTime.now().format(DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm"))}
    """;

// Templates para diferentes formatos
public class TemplateExamples {
    
    // JSON seguro
    public String generateJson(User user) {
        return STR."""
            {
                "id": \{user.getId()},
                "name": "\{user.getName()}",
                "email": "\{user.getEmail()}",
                "active": \{user.isActive()},
                "lastLogin": "\{user.getLastLogin()?.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)}",
                "roles": [\{user.getRoles().stream()
                    .map(role -> STR."\"\{role}\"")
                    .collect(Collectors.joining(", "))}]
            }
            """;
    }
    
    // SQL Templates (type-safe!)
    public String buildQuery(String table, List<String> columns, Map<String, Object> filters) {
        var columnList = String.join(", ", columns);
        var whereClause = filters.entrySet().stream()
            .map(entry -> STR."\{entry.getKey()} = ?\{entry.getValue()}")
            .collect(Collectors.joining(" AND "));
            
        return STR."""
            SELECT \{columnList}
            FROM \{table}
            WHERE \{whereClause}
            ORDER BY created_at DESC
            """;
    }
    
    // HTML Templates
    public String generateCard(Product product) {
        return STR."""
            <div class="product-card">
                <h3>\{product.getName()}</h3>
                <p class="description">\{product.getDescription()}</p>
                <div class="price">
                    <span class="currency">R$</span>
                    <span class="amount">\{product.getPrice():%.2f}</span>
                </div>
                <div class="stock \{product.getStock() > 0 ? "in-stock" : "out-of-stock"}">
                    \{product.getStock() > 0 ? 
                        STR."\{product.getStock()} disponÃ­veis" : 
                        "Fora de estoque"}
                </div>
            </div>
            """;
    }
}
```

#### ğŸ›¡ï¸ Templates Customizados

```java
// Template processor customizado para SQL
public static final StringTemplate.Processor<PreparedStatement, SQLException> SQL = 
    (StringTemplate template) -> {
        String query = StringTemplate.STR.process(template);
        return connection.prepareStatement(query);
    };

// Uso seguro contra SQL injection
public List<User> findUsers(String namePattern, int minAge) throws SQLException {
    PreparedStatement stmt = SQL."""
        SELECT * FROM users 
        WHERE name LIKE \{namePattern}
        AND age >= \{minAge}
        ORDER BY name
        """;
    
    // PreparedStatement jÃ¡ configurado!
    return executeQuery(stmt);
}

// Template para logs estruturados
public static final StringTemplate.Processor<LogEvent, RuntimeException> LOG = 
    (StringTemplate template) -> {
        // Processa template e cria evento de log estruturado
        var processed = StringTemplate.STR.process(template);
        return new LogEvent(Level.INFO, processed, Instant.now());
    };

// Uso
LogEvent event = LOG."User \{userId} performed action \{action} at \{timestamp}";
logger.log(event);
```

### ğŸ”¹ Pattern Matching for Switch (Final)

#### â“ O que Ã©?
Switch melhorado que suporta pattern matching com qualquer tipo e guards.

#### ğŸ’¡ Exemplo Simples
```java
// Pattern matching com tipos
public String processValue(Object value) {
    return switch (value) {
        case String s when s.length() > 10 -> "String longa: " + s;
        case String s -> "String curta: " + s;
        case Integer i when i > 0 -> "NÃºmero positivo: " + i;
        case Integer i -> "NÃºmero nÃ£o positivo: " + i;
        case null -> "Valor nulo";
        default -> "Tipo desconhecido: " + value.getClass();
    };
}

// Com Records
record Point(int x, int y) {}
record Circle(Point center, int radius) {}

public String analyzeShape(Object shape) {
    return switch (shape) {
        case Circle(Point(int x, int y), int r) when r > 10 -> 
            STR."CÃ­rculo grande em (\{x}, \{y}) com raio \{r}";
        case Circle(Point(int x, int y), int r) -> 
            STR."CÃ­rculo pequeno em (\{x}, \{y}) com raio \{r}";
        case Point(int x, int y) -> STR."Ponto em (\{x}, \{y})";
        default -> "Forma desconhecida";
    };
}
```

### ğŸ”¹ Sequenced Collections

#### â“ O que Ã©?
Nova interface que representa coleÃ§Ãµes com ordem definida, oferecendo acesso ao primeiro e Ãºltimo elemento.

#### ğŸ’¡ Exemplo Simples
```java
// SequencedCollection interface
List<String> list = List.of("primeiro", "meio", "Ãºltimo");

// MÃ©todos novos
String primeiro = list.getFirst();  // "primeiro"
String ultimo = list.getLast();     // "Ãºltimo"

// Reversed view
List<String> reverso = list.reversed();
// ["Ãºltimo", "meio", "primeiro"]

// Com Set tambÃ©m
LinkedHashSet<String> set = new LinkedHashSet<>();
set.add("a");
set.add("b");
set.add("c");

String primeiroSet = set.getFirst(); // "a"
String ultimoSet = set.getLast();    // "c"
```

### ğŸ”¹ Record Patterns (Final)

#### â“ O que Ã©?
Permite desestruturar Records diretamente em pattern matching.

#### ğŸ’¡ Exemplo Simples
```java
record Person(String name, int age) {}
record Employee(Person person, String department) {}

public String processEmployee(Employee emp) {
    return switch (emp) {
        // DesestruturaÃ§Ã£o aninhada
        case Employee(Person(String name, int age), String dept) 
            when age < 25 -> STR."\{name} Ã© estagiÃ¡rio em \{dept}";
        case Employee(Person(String name, int age), String dept) 
            when age > 50 -> STR."\{name} Ã© sÃªnior em \{dept}";
        case Employee(Person(String name, int age), String dept) -> 
            STR."\{name} (\{age} anos) trabalha em \{dept}";
    };
}
```

### ğŸ”¹ Key Encapsulation Mechanism API

#### â“ O que Ã©?
API para algoritmos criptogrÃ¡ficos quantum-safe, preparando Java para a era pÃ³s-quÃ¢ntica.

#### ğŸ’¡ Exemplo Simples
```java
// Gerar par de chaves para KEM
KeyPairGenerator kpg = KeyPairGenerator.getInstance("ML-KEM");
KeyPair keyPair = kpg.generateKeyPair();

// Encapsular segredo
KEM kem = KEM.getInstance("ML-KEM");
KEM.Encapsulator encapsulator = kem.newEncapsulator(keyPair.getPublic());
KEM.Encapsulated encapsulated = encapsulator.encapsulate();

byte[] sharedSecret = encapsulated.key();
byte[] encapsulation = encapsulated.encapsulation();
```

---

## ğŸ”§ Outras Melhorias Importantes

### âš¡ Performance
- **Generational ZGC**: Garbage Collection ainda mais eficiente
- **Prepare to Restrict Dynamic Loading**: Melhor seguranÃ§a
- **Dynamic CDS Archives**: Startup mais rÃ¡pido

### ğŸ› ï¸ APIs
- **Math.clamp()**: Limitar valores a um range
- **StringBuilder/StringBuffer repeat()**: Repetir sequÃªncias
- **Emoji support**: Melhor suporte a caracteres Unicode

---

---

## ğŸ¯ Impacto e RevoluÃ§Ã£o

Java 21 representa **a maior revoluÃ§Ã£o** desde Java 8:

- âœ… **Virtual Threads** eliminam limitaÃ§Ãµes de concorrÃªncia
- âœ… **String Templates** modernizam manipulaÃ§Ã£o de strings
- âœ… **Pattern Matching avanÃ§ado** simplifica lÃ³gica complexa
- âœ… **Sequenced Collections** melhoram APIs de coleÃ§Ã£o
- âœ… **Performance excepcional** para aplicaÃ§Ãµes I/O intensivas
- âœ… **Preparado para futuro** quantum-safe
- âœ… **Compatibilidade total** com cÃ³digo existente

## ğŸ“Š ComparaÃ§Ã£o de LTS

| Aspecto | Java 8 | Java 11 | Java 17 | **Java 21** |
|---------|---------|---------|---------|-------------|
| **ConcorrÃªncia** | Threads tradicionais | Threads tradicionais | Threads tradicionais | **ğŸš€ Virtual Threads** |
| **String Templates** | âŒ | âŒ | âŒ | **âœ… Preview** |
| **Pattern Matching** | âŒ | âŒ | instanceof | **âœ… Switch avanÃ§ado** |
| **Record Patterns** | âŒ | âŒ | âŒ | **âœ… Final** |
| **Sequenced Collections** | âŒ | âŒ | âŒ | **âœ… Final** |
| **Quantum-safe Crypto** | âŒ | âŒ | âŒ | **âœ… KEM API** |
| **Performance I/O** | Thread pools | Thread pools | Thread pools | **ğŸš€ Massivamente escalÃ¡vel** |

---

## ğŸ“… InformaÃ§Ãµes da VersÃ£o

- **ğŸ“… LanÃ§amento**: 19 de setembro de 2023
- **ğŸ”§ Tipo**: LTS (Long Term Support)
- **âš¡ Suporte Oracle**: AtÃ© setembro de 2031 (Extended atÃ© 2034)
- **ğŸ†“ Suporte Gratuito**: Eclipse Temurin, Amazon Corretto, Microsoft OpenJDK
- **ğŸ¯ Status**: **LTS revolucionÃ¡ria** - nova referÃªncia para alta performance
- **ğŸ”„ MigraÃ§Ã£o**: FÃ¡cil - principalmente additive features

---

## ğŸ”— Links Ãšteis

### ğŸ“š **DocumentaÃ§Ã£o Oficial**
- [Java 21 Documentation](https://docs.oracle.com/en/java/javase/21/)
- [Java 21 API Specification](https://docs.oracle.com/en/java/javase/21/docs/api/)
- [All JEPs in Java 21](https://openjdk.org/projects/jdk/21/)

### ğŸ§µ **Virtual Threads**
- [Virtual Threads Guide](https://openjdk.org/jeps/444)
- [Virtual Threads Tutorial](https://www.baeldung.com/java-virtual-thread-vs-thread)
- [Loom Project](https://openjdk.org/projects/loom/)
- [Virtual Threads Best Practices](https://spring.io/blog/2022/10/11/embracing-virtual-threads)

### ğŸ¨ **String Templates**
- [String Templates JEP](https://openjdk.org/jeps/430)
- [String Interpolation Guide](https://www.baeldung.com/java-string-templates)

### ğŸ” **Pattern Matching**
- [Pattern Matching for Switch](https://openjdk.org/jeps/441)
- [Record Patterns](https://openjdk.org/jeps/440)
- [Pattern Matching Tutorial](https://www.baeldung.com/java-pattern-matching-switch)

### ğŸ“š **Collections**
- [Sequenced Collections](https://openjdk.org/jeps/431)
- [Collections Framework](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/doc-files/coll-overview.html)

### ğŸ”’ **SeguranÃ§a**
- [Key Encapsulation Mechanism](https://openjdk.org/jeps/452)
- [Quantum-Safe Cryptography](https://www.nist.gov/news-events/news/2022/07/nist-announces-first-four-quantum-resistant-cryptographic-algorithms)

### ğŸ’» **Exemplos e PrÃ¡ticas**
- [Java 21 Features Examples](https://www.baeldung.com/java-21-new-features)
- [Modern Java Development](https://github.com/openjdk/jdk21)
- [Virtual Threads Cookbook](https://github.com/ebarlas/virtual-threads-examples) 