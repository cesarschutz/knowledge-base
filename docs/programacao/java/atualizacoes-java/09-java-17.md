# 1ï¸âƒ£7ï¸âƒ£ Java 17 LTS (2021)

# ğŸš€ Java 17 LTS - A LTS Moderna e EstÃ¡vel

## ğŸ“– Sobre o Java 17

Java 17 Ã© **a versÃ£o LTS atual mais adotada**, marcando um momento especial na evoluÃ§Ã£o do Java. LanÃ§ado em setembro de 2021, consolida todas as inovaÃ§Ãµes desde Java 11, oferecendo **Records**, **Sealed Classes**, **Pattern Matching** e **Text Blocks** em versÃ£o final. Ã‰ a escolha padrÃ£o para novos projetos que buscam modernidade com estabilidade LTS.

## ğŸ’¡ O que sÃ£o JEPs?
Java 17 incluiu 14 JEPs que consolidaram preview features em funcionalidades finais e introduziram melhorias significativas de performance e seguranÃ§a.

---

## ğŸ—ï¸ Modelagem de Dados

### ğŸ”¹ JEP 409: Sealed Classes (Final)

#### â“ O que Ã©?
Classes que explicitamente controlam quais outras classes podem estendÃª-las, oferecendo melhor modelagem de domÃ­nio e type safety.

#### âš ï¸ Por que Ã© importante?
Permite criar hierarquias de classes fechadas e controladas, melhorando a modelagem de domÃ­nio e habilitando pattern matching exhaustivo.

```java
// Modelagem de formas geomÃ©tricas
public sealed class Shape 
    permits Circle, Rectangle, Triangle {
    
    public abstract double area();
    public abstract double perimeter();
}

// ImplementaÃ§Ãµes finais
public final class Circle extends Shape {
    private final double radius;
    
    public Circle(double radius) {
        if (radius <= 0) throw new IllegalArgumentException("Radius must be positive");
        this.radius = radius;
    }
    
    @Override
    public double area() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public double perimeter() {
        return 2 * Math.PI * radius;
    }
    
    public double radius() { return radius; }
}

public final class Rectangle extends Shape {
    private final double width, height;
    
    public Rectangle(double width, double height) {
        if (width <= 0 || height <= 0) {
            throw new IllegalArgumentException("Dimensions must be positive");
        }
        this.width = width;
        this.height = height;
    }
    
    @Override
    public double area() { return width * height; }
    
    @Override
    public double perimeter() { return 2 * (width + height); }
    
    public double width() { return width; }
    public double height() { return height; }
}

// Sealed interfaces tambÃ©m sÃ£o possÃ­veis
public sealed interface Payment 
    permits CreditCardPayment, PayPalPayment, CashPayment {
    double amount();
    void process();
}

// Hierarquia nÃ£o selada dentro de sealed
public sealed class Animal permits Mammal, Bird {
    protected final String name;
    protected Animal(String name) { this.name = name; }
}

public non-sealed class Mammal extends Animal {
    protected Mammal(String name) { super(name); }
}

// Agora qualquer classe pode estender Mammal
public class Dog extends Mammal {
    public Dog(String name) { super(name); }
}

public class Cat extends Mammal {
    public Cat(String name) { super(name); }
}
```

#### ğŸ¯ Pattern Matching com Sealed Classes
```java
// Pattern matching exhaustivo (futuro)
public String processShape(Shape shape) {
    return switch (shape) {
        case Circle c -> "Circle with radius " + c.radius();
        case Rectangle r -> "Rectangle " + r.width() + "x" + r.height();
        case Triangle t -> "Triangle"; 
        // NÃ£o precisa de default - compilador sabe que Ã© exhaustivo
    };
}

// Processamento de pagamentos
public void processPayment(Payment payment) {
    switch (payment) {
        case CreditCardPayment cc -> {
            validateCard(cc.cardNumber());
            chargeCard(cc);
        }
        case PayPalPayment pp -> {
            authenticatePayPal(pp.email());
            processPayPal(pp);
        }
        case CashPayment cash -> {
            recordCashTransaction(cash);
        }
    };
}
```

ğŸ“š **Saiba mais**: [Sealed Classes JEP](https://openjdk.org/jeps/409)

### ğŸ”¹ JEP 395: Records (Final)

#### â“ O que Ã©?
Classes compactas para dados imutÃ¡veis que geram automaticamente `equals()`, `hashCode()`, `toString()` e getters.

#### âš ï¸ Por que Ã© importante?
Elimina boilerplate para data classes, promove imutabilidade e melhora legibilidade do cÃ³digo.

```java
// Record bÃ¡sico
public record Person(String name, int age, String email) {}

// Uso automÃ¡tico de todos os mÃ©todos
Person person = new Person("Ana Silva", 30, "ana@example.com");
System.out.println(person.name());     // Ana Silva
System.out.println(person.age());      // 30
System.out.println(person);            // Person[name=Ana Silva, age=30, email=ana@example.com]

// Equals e hashCode funcionam corretamente
Person person1 = new Person("JoÃ£o", 25, "joao@test.com");
Person person2 = new Person("JoÃ£o", 25, "joao@test.com");
System.out.println(person1.equals(person2)); // true
System.out.println(person1.hashCode() == person2.hashCode()); // true

// Record com validaÃ§Ã£o no constructor compacto
public record Product(String name, double price, String category) {
    public Product {
        // ValidaÃ§Ãµes aplicadas a todos os constructors
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("Name cannot be null or blank");
        }
        if (price < 0) {
            throw new IllegalArgumentException("Price cannot be negative");
        }
        if (category == null) {
            throw new IllegalArgumentException("Category cannot be null");
        }
        
        // NormalizaÃ§Ã£o
        name = name.trim();
        category = category.toLowerCase();
    }
    
    // MÃ©todos customizados
    public boolean isExpensive() {
        return price > 100.0;
    }
    
    public Product withDiscount(double percentage) {
        if (percentage < 0 || percentage > 100) {
            throw new IllegalArgumentException("Invalid discount percentage");
        }
        double newPrice = price * (100 - percentage) / 100;
        return new Product(name, newPrice, category);
    }
}

// Record com mÃºltiplos constructors
public record Point(int x, int y) {
    
    // Constructor alternativo
    public Point(int value) {
        this(value, value); // Chama constructor canonical
    }
    
    // MÃ©todos Ãºteis
    public double distanceFromOrigin() {
        return Math.sqrt(x * x + y * y);
    }
    
    public Point translate(int deltaX, int deltaY) {
        return new Point(x + deltaX, y + deltaY);
    }
    
    // Static factory methods
    public static Point origin() {
        return new Point(0, 0);
    }
    
    public static Point of(int x, int y) {
        return new Point(x, y);
    }
}

// Record para configuraÃ§Ã£o
public record DatabaseConfig(
    String host, 
    int port, 
    String database, 
    String username, 
    String password,
    int maxConnections
) {
    public DatabaseConfig {
        if (port < 1 || port > 65535) {
            throw new IllegalArgumentException("Invalid port: " + port);
        }
        if (maxConnections < 1) {
            throw new IllegalArgumentException("Max connections must be positive");
        }
    }
    
    public String jdbcUrl() {
        return "jdbc:postgresql://" + host + ":" + port + "/" + database;
    }
}
```

#### ğŸ”„ Records vs Classes Tradicionais
```java
// Antes - classe tradicional (muito cÃ³digo!)
public class PersonOld {
    private final String name;
    private final int age;
    private final String email;
    
    public PersonOld(String name, int age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }
    
    public String getName() { return name; }
    public int getAge() { return age; }
    public String getEmail() { return email; }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        PersonOld person = (PersonOld) obj;
        return age == person.age &&
               Objects.equals(name, person.name) &&
               Objects.equals(email, person.email);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(name, age, email);
    }
    
    @Override
    public String toString() {
        return "PersonOld{name='" + name + "', age=" + age + ", email='" + email + "'}";
    }
}

// Java 17 - Record (1 linha!)
public record Person(String name, int age, String email) {}
```

ğŸ“š **Saiba mais**: [Records Tutorial](https://openjdk.org/jeps/395)

---

## ğŸ” Pattern Matching

### ğŸ”¹ JEP 394: Pattern Matching for instanceof (Final)

#### â“ O que Ã©?
Simplifica verificaÃ§Ãµes de tipo eliminando casting manual, introduzindo variÃ¡veis de padrÃ£o.

#### âš ï¸ Por que Ã© importante?
Reduz cÃ³digo verbose, elimina erros de casting e torna verificaÃ§Ãµes de tipo mais expressivas.

```java
// Antes do Java 17 - verbose e propenso a erros
public String formatValue(Object obj) {
    if (obj instanceof String) {
        String str = (String) obj;  // casting manual obrigatÃ³rio
        return "String: " + str.toUpperCase();
    } else if (obj instanceof Integer) {
        Integer num = (Integer) obj;  // mais casting manual
        return "Number: " + (num * 2);
    } else if (obj instanceof List) {
        List<?> list = (List<?>) obj;  // casting complexo
        return "List with " + list.size() + " elements";
    }
    return "Unknown type: " + obj.getClass().getSimpleName();
}

// Java 17 - Pattern Matching limpo
public String formatValue(Object obj) {
    if (obj instanceof String str) {           // casting automÃ¡tico!
        return "String: " + str.toUpperCase();
    } else if (obj instanceof Integer num) {   // variÃ¡vel disponÃ­vel imediatamente
        return "Number: " + (num * 2);
    } else if (obj instanceof List<?> list) {  // funciona com generics
        return "List with " + list.size() + " elements";
    }
    return "Unknown type: " + obj.getClass().getSimpleName();
}

// Exemplo mais complexo: processamento de JSON
public void processJsonValue(Object value) {
    if (value instanceof String str && !str.isBlank()) {
        // VariÃ¡vel str sÃ³ existe se ambas condiÃ§Ãµes forem verdadeiras
        processStringValue(str.trim());
    } else if (value instanceof Number num && num.doubleValue() > 0) {
        // num sÃ³ existe se for Number E positivo
        processPositiveNumber(num);
    } else if (value instanceof List<?> list && !list.isEmpty()) {
        // VerificaÃ§Ã£o combinada com pattern matching
        processNonEmptyList(list);
    } else if (value instanceof Map<?, ?> map && map.containsKey("type")) {
        // Pattern matching com verificaÃ§Ã£o de conteÃºdo
        processTypedMap(map);
    }
}

// Uso em Ã¡rvores e estruturas recursivas
public sealed interface Node permits LeafNode, BranchNode {}
public record LeafNode(String value) implements Node {}
public record BranchNode(Node left, Node right) implements Node {}

public int countNodes(Node node) {
    if (node instanceof LeafNode leaf) {
        return 1;
    } else if (node instanceof BranchNode branch) {
        return 1 + countNodes(branch.left()) + countNodes(branch.right());
    }
    return 0; // Nunca alcanÃ§ado por sealed classes
}

// ValidaÃ§Ã£o e transformaÃ§Ã£o segura
public Optional<Integer> parsePositiveInt(Object value) {
    if (value instanceof String str && str.matches("\\d+")) {
        int parsed = Integer.parseInt(str);
        return parsed > 0 ? Optional.of(parsed) : Optional.empty();
    } else if (value instanceof Number num && num.intValue() > 0) {
        return Optional.of(num.intValue());
    }
    return Optional.empty();
}
```

#### ğŸ¯ Combinando com Guard Conditions
```java
// Pattern matching com guards (condiÃ§Ãµes adicionais)
public String categorizeValue(Object obj) {
    if (obj instanceof String str && str.length() > 10) {
        return "Long string: " + str.substring(0, 10) + "...";
    } else if (obj instanceof String str && str.length() <= 10) {
        return "Short string: " + str;
    } else if (obj instanceof Integer num && num > 100) {
        return "Large number: " + num;
    } else if (obj instanceof Integer num && num >= 0) {
        return "Small number: " + num;
    } else if (obj instanceof Integer num) {
        return "Negative number: " + num;
    }
    return "Other: " + obj;
}
```

ğŸ“š **Saiba mais**: [Pattern Matching for instanceof](https://openjdk.org/jeps/394)

---

## ğŸ“ String e Text Blocks

### ğŸ”¹ JEP 378: Text Blocks (Final)

#### â“ O que Ã©?
Strings multilinha sem necessidade de escape, preservando formataÃ§Ã£o natural.

#### âš ï¸ Por que Ã© importante?
Elimina concatenaÃ§Ã£o verbosa para HTML, SQL, JSON, YAML e outros formatos estruturados.

```java
// Antes - JSON verboso e propenso a erros
String jsonBefore = "{\n" +
                   "  \"user\": {\n" +
                   "    \"name\": \"JoÃ£o Silva\",\n" +
                   "    \"age\": 30,\n" +
                   "    \"active\": true,\n" +
                   "    \"roles\": [\"user\", \"admin\"],\n" +
                   "    \"metadata\": {\n" +
                   "      \"lastLogin\": \"2024-01-15T10:30:00Z\",\n" +
                   "      \"preferences\": {\n" +
                   "        \"theme\": \"dark\",\n" +
                   "        \"language\": \"pt-BR\"\n" +
                   "      }\n" +
                   "    }\n" +
                   "  }\n" +
                   "}";

// Java 17 - Text Block elegante
String json = """
    {
      "user": {
        "name": "JoÃ£o Silva",
        "age": 30,
        "active": true,
        "roles": ["user", "admin"],
        "metadata": {
          "lastLogin": "2024-01-15T10:30:00Z",
          "preferences": {
            "theme": "dark",
            "language": "pt-BR"
          }
        }
      }
    }
    """;

// SQL complexo legÃ­vel
String complexQuery = """
    WITH user_stats AS (
        SELECT 
            u.id,
            u.name,
            COUNT(p.id) as post_count,
            AVG(p.rating) as avg_rating,
            MAX(p.created_at) as last_post
        FROM users u
        LEFT JOIN posts p ON u.id = p.user_id
        WHERE u.active = true
          AND u.created_at > '2020-01-01'
        GROUP BY u.id, u.name
        HAVING COUNT(p.id) > 5
    )
    SELECT 
        us.*,
        CASE 
            WHEN us.avg_rating >= 4.5 THEN 'Excellent'
            WHEN us.avg_rating >= 3.5 THEN 'Good'
            WHEN us.avg_rating >= 2.5 THEN 'Average'
            ELSE 'Poor'
        END as performance_category
    FROM user_stats us
    ORDER BY us.post_count DESC, us.avg_rating DESC
    LIMIT 50
    """;

// HTML template
String htmlTemplate = """
    <!DOCTYPE html>
    <html lang="pt-BR">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>%s</title>
        <style>
            body { 
                font-family: 'Segoe UI', sans-serif; 
                margin: 0; 
                padding: 20px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            }
            .container { 
                max-width: 800px; 
                margin: 0 auto; 
                background: white;
                border-radius: 10px;
                padding: 30px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            }
            h1 { 
                color: #333; 
                text-align: center;
                margin-bottom: 30px;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>%s</h1>
            <div class="content">
                %s
            </div>
        </div>
    </body>
    </html>
    """;

// YAML configuration
String yamlConfig = """
    application:
      name: MyApp
      version: 1.0.0
      
    server:
      port: 8080
      context-path: /api
      
    database:
      driver: postgresql
      host: localhost
      port: 5432
      name: myappdb
      pool:
        min-size: 5
        max-size: 20
        timeout: 30s
        
    logging:
      level:
        root: INFO
        com.myapp: DEBUG
      pattern: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
      
    features:
      - authentication
      - authorization  
      - caching
      - monitoring
    """;
```

#### ğŸ”§ Text Block Features AvanÃ§adas
```java
// Controle de indentaÃ§Ã£o
String code = """
    public class Example {
        public void method() {
            System.out.println("Hello");
        }
    }
    """.stripIndent();  // Remove indentaÃ§Ã£o comum

// FormataÃ§Ã£o com parÃ¢metros (Java 15+)
String message = """
    OlÃ¡ %s!
    
    VocÃª tem %d mensagens nÃ£o lidas.
    Ãšltima atividade: %s
    
    Status da conta: %s
    """.formatted(userName, messageCount, lastActivity, accountStatus);

// Templates para diferentes formatos
public class TemplateGenerator {
    public String generateDockerfile(String baseImage, String appName, int port) {
        return """
            FROM %s
            
            WORKDIR /app
            
            COPY target/%s.jar app.jar
            
            EXPOSE %d
            
            ENV JAVA_OPTS="-Xmx512m -Xms256m"
            
            CMD ["java", "$JAVA_OPTS", "-jar", "app.jar"]
            """.formatted(baseImage, appName, port);
    }
    
    public String generateKubernetesService(String appName, int port) {
        return """
            apiVersion: v1
            kind: Service
            metadata:
              name: %s-service
              labels:
                app: %s
            spec:
              selector:
                app: %s
              ports:
                - protocol: TCP
                  port: %d
                  targetPort: %d
              type: ClusterIP
            """.formatted(appName, appName, appName, port, port);
    }
}
```

ğŸ“š **Saiba mais**: [Text Blocks Guide](https://openjdk.org/jeps/378)

---

## ğŸ¯ Switch Expressions

### ğŸ”¹ JEP 361: Switch Expressions (Final)

#### â“ O que Ã©?
Switch como expressÃ£o que retorna valores, com sintaxe mais concisa e sem fall-through.

#### âš ï¸ Por que Ã© importante?
Elimina bugs de fall-through, torna cÃ³digo mais funcional e expressivo.

```java
// Antes - switch statement verboso
public String getDayTypeOld(DayOfWeek day) {
    String result;
    switch (day) {
        case MONDAY:
        case TUESDAY:
        case WEDNESDAY:
        case THURSDAY:
        case FRIDAY:
            result = "Weekday";
            break;
        case SATURDAY:
        case SUNDAY:
            result = "Weekend";
            break;
        default:
            result = "Invalid day";
            break;
    }
    return result;
}

// Java 17 - Switch Expression conciso
public String getDayType(DayOfWeek day) {
    return switch (day) {
        case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -> "Weekday";
        case SATURDAY, SUNDAY -> "Weekend";
    };  // NÃ£o precisa de default - enum Ã© exhaustivo
}

// Casos mais complexos com yield
public int calculateShippingCost(OrderType type, double weight, String destination) {
    return switch (type) {
        case STANDARD -> {
            int baseCost = 10;
            if (weight > 5.0) baseCost += 5;
            if ("INTERNATIONAL".equals(destination)) baseCost *= 3;
            yield baseCost;
        }
        case EXPRESS -> {
            int cost = 25;
            yield "INTERNATIONAL".equals(destination) ? cost * 2 : cost;
        }
        case OVERNIGHT -> {
            if ("INTERNATIONAL".equals(destination)) {
                throw new IllegalArgumentException("Overnight not available internationally");
            }
            yield 50;
        }
    };
}

// Switch com pattern matching (preview em versÃµes posteriores)
public String processPayment(Object payment) {
    return switch (payment) {
        case CreditCard(var number, var expiry) -> 
            "Processing credit card ending in " + number.substring(number.length() - 4);
        case PayPal(var email) -> 
            "Processing PayPal payment for " + email;
        case Cash(var amount) -> 
            "Processing cash payment of $" + amount;
        case null -> 
            "No payment method provided";
        default -> 
            "Unknown payment type: " + payment.getClass().getSimpleName();
    };
}

// Calculadora expressiva
public double calculate(String operation, double a, double b) {
    return switch (operation.toLowerCase()) {
        case "+", "add", "plus" -> a + b;
        case "-", "subtract", "minus" -> a - b;
        case "*", "multiply", "times" -> a * b;
        case "/", "divide" -> {
            if (b == 0) throw new ArithmeticException("Division by zero");
            yield a / b;
        }
        case "^", "power", "pow" -> Math.pow(a, b);
        case "%", "mod", "modulo" -> a % b;
        default -> throw new IllegalArgumentException("Unknown operation: " + operation);
    };
}

// Estado de mÃ¡quina simplificado
public enum State { IDLE, RUNNING, PAUSED, STOPPED }
public enum Event { START, PAUSE, RESUME, STOP }

public State transition(State currentState, Event event) {
    return switch (currentState) {
        case IDLE -> switch (event) {
            case START -> State.RUNNING;
            case STOP -> State.STOPPED;
            default -> currentState; // Sem transiÃ§Ã£o
        };
        case RUNNING -> switch (event) {
            case PAUSE -> State.PAUSED;
            case STOP -> State.STOPPED;
            default -> currentState;
        };
        case PAUSED -> switch (event) {
            case RESUME -> State.RUNNING;
            case STOP -> State.STOPPED;
            default -> currentState;
        };
        case STOPPED -> switch (event) {
            case START -> State.RUNNING;
            default -> currentState;
        };
    };
}
```

ğŸ“š **Saiba mais**: [Switch Expressions Guide](https://openjdk.org/jeps/361)

---

## ğŸŒŠ Stream Enhancements

### ğŸ”¹ Stream.toList()

#### â“ O que Ã©?
MÃ©todo conveniente para coletar Stream em List imutÃ¡vel.

#### âš ï¸ Por que Ã© importante?
Elimina verbosidade de `collect(Collectors.toList())` e retorna lista imutÃ¡vel por padrÃ£o.

```java
List<String> names = List.of("ana", "joÃ£o", "maria", "pedro", "carlos");

// Antes do Java 17 - verboso
List<String> upperNamesOld = names.stream()
    .map(String::toUpperCase)
    .filter(name -> name.length() > 4)
    .collect(Collectors.toList());  // MutÃ¡vel

// Java 17 - conciso e imutÃ¡vel
List<String> upperNames = names.stream()
    .map(String::toUpperCase)
    .filter(name -> name.length() > 4)
    .toList();  // ImutÃ¡vel!

// Exemplo prÃ¡tico: processamento de dados
public class DataProcessor {
    
    public List<ProductDto> getActiveProducts(List<Product> products) {
        return products.stream()
            .filter(Product::isActive)
            .filter(p -> p.getStock() > 0)
            .map(this::toDto)
            .sorted(Comparator.comparing(ProductDto::name))
            .toList();  // Lista imutÃ¡vel
    }
    
    public List<String> extractValidEmails(List<User> users) {
        return users.stream()
            .map(User::getEmail)
            .filter(Objects::nonNull)
            .filter(this::isValidEmail)
            .map(String::toLowerCase)
            .distinct()
            .toList();
    }
    
    // Combinando com records
    public List<UserSummary> generateUserSummaries(List<User> users) {
        return users.stream()
            .filter(User::isActive)
            .map(user -> new UserSummary(
                user.getName(),
                user.getEmail(),
                user.getOrders().size(),
                user.getTotalSpent()
            ))
            .sorted(Comparator.comparing(UserSummary::totalSpent).reversed())
            .toList();
    }
}

// Record para o exemplo acima
public record UserSummary(
    String name, 
    String email, 
    int orderCount, 
    BigDecimal totalSpent
) {}
```

---

## ğŸš€ Performance e JVM

### ğŸ”¹ JEP 356: Enhanced Pseudo-Random Number Generators

#### â“ O que Ã©?
Nova API para geradores de nÃºmeros aleatÃ³rios com melhor design e performance.

#### âš ï¸ Por que Ã© importante?
Oferece algoritmos modernos de geraÃ§Ã£o aleatÃ³ria com melhor distribuiÃ§Ã£o e performance.

```java
// Nova API RandomGenerator
RandomGenerator random = RandomGenerator.getDefault();

// Diferentes algoritmos disponÃ­veis
RandomGenerator xoshiro = RandomGenerator.of("Xoshiro256PlusPlus");
RandomGenerator l128x256 = RandomGenerator.of("L128X256MixRandom");

// Streams de nÃºmeros aleatÃ³rios
List<Integer> randomInts = random.ints(100, 1, 101)  // 100 nÃºmeros entre 1-100
    .boxed()
    .toList();

// GeraÃ§Ã£o paralela para performance
IntStream.range(0, 1_000_000)
    .parallel()
    .map(i -> random.nextInt(1000))
    .distinct()
    .limit(100)
    .forEach(System.out::println);
```

### ğŸ”¹ JEP 382: New macOS Rendering Pipeline

#### â“ O que Ã©?
Pipeline de renderizaÃ§Ã£o nativo para macOS usando Metal ao invÃ©s de OpenGL deprecated.

#### âš ï¸ Por que Ã© importante?
Melhora performance grÃ¡fica significativamente no macOS e prepara para futuro sem OpenGL.

### ğŸ”¹ JEP 391: macOS/AArch64 Port

#### â“ O que Ã©?
Suporte nativo para processadores Apple Silicon (M1, M2, etc.).

#### âš ï¸ Por que Ã© importante?
Performance nativa em Macs com Apple Silicon, sem emulaÃ§Ã£o Rosetta.

```bash
# Verificar arquitetura
java -XshowSettings:properties -version | grep os.arch
# SaÃ­da em Apple Silicon: os.arch = aarch64
```

---

## ğŸ”’ SeguranÃ§a e Internals

### ğŸ”¹ JEP 403: Strongly Encapsulate JDK Internals

#### â“ O que Ã©?
Torna APIs internas do JDK fortemente encapsuladas, impedindo acesso nÃ£o autorizado.

#### âš ï¸ Por que Ã© importante?
Aumenta seguranÃ§a e estabilidade, forÃ§ando uso de APIs pÃºblicas.

```java
// Isso nÃ£o funciona mais no Java 17:
// sun.misc.Unsafe unsafe = sun.misc.Unsafe.getUnsafe(); // âŒ

// Use APIs pÃºblicas:
var byteBuffer = ByteBuffer.allocateDirect(1024); // âœ…
```

### ğŸ”¹ JEP 415: Context-Specific Deserialization Filters

#### â“ O que Ã©?
Filtros de deserializaÃ§Ã£o especÃ­ficos por contexto para melhor seguranÃ§a.

#### âš ï¸ Por que Ã© importante?
Previne ataques de deserializaÃ§Ã£o maliciosa de forma mais granular.

---

## ğŸ› ï¸ Ferramentas

### ğŸ”¹ JEP 392: Packaging Tool (jpackage)

#### â“ O que Ã©?
Ferramenta para criar instaladores nativos de aplicaÃ§Ãµes Java.

#### âš ï¸ Por que Ã© importante?
Facilita distribuiÃ§Ã£o de aplicaÃ§Ãµes Java como aplicaÃ§Ãµes nativas do sistema.

```bash
# Criar instalador Windows (.msi)
jpackage --input target/ \
         --name MyApp \
         --main-jar myapp.jar \
         --main-class com.example.Main \
         --type msi \
         --dest dist/

# Criar App Bundle macOS (.app)
jpackage --input target/ \
         --name MyApp \
         --main-jar myapp.jar \
         --main-class com.example.Main \
         --type app-image \
         --dest dist/

# Criar package Debian (.deb)
jpackage --input target/ \
         --name MyApp \
         --main-jar myapp.jar \
         --main-class com.example.Main \
         --type deb \
         --dest dist/
```

---

## ğŸ¯ Impacto e AdoÃ§Ã£o

Java 17 Ã© **a LTS moderna** mais importante:

- âœ… **Records e Sealed Classes** revolucionaram modelagem de dados
- âœ… **Pattern Matching** simplificou verificaÃ§Ãµes de tipo
- âœ… **Text Blocks** melhoraram legibilidade de cÃ³digo
- âœ… **Switch Expressions** tornaram cÃ³digo mais funcional
- âœ… **Performance excelente** com Apple Silicon e melhorias de GC
- âœ… **Amplamente adotado** pela indÃºstria como padrÃ£o
- âœ… **Base sÃ³lida** para aplicaÃ§Ãµes modernas

---

## ğŸ“Š ComparaÃ§Ã£o com Outras LTS

| Aspecto | Java 8 | Java 11 | **Java 17** | Java 21 |
|---------|---------|---------|-------------|---------|
| **Paradigma** | Funcional | Modular | **Moderno** | AvanÃ§ado |
| **Data Classes** | âŒ | âŒ | **âœ… Records** | âœ… |
| **Pattern Matching** | âŒ | âŒ | **âœ… instanceof** | âœ… AvanÃ§ado |
| **Sealed Classes** | âŒ | âŒ | **âœ…** | âœ… |
| **Text Blocks** | âŒ | âŒ | **âœ…** | âœ… |
| **Switch Expressions** | âŒ | âŒ | **âœ…** | âœ… |
| **Virtual Threads** | âŒ | âŒ | âŒ | âœ… |

---

## ğŸ“… InformaÃ§Ãµes da VersÃ£o

- **ğŸ“… LanÃ§amento**: 14 de setembro de 2021
- **ğŸ”§ Tipo**: LTS (Long Term Support)
- **âš¡ Suporte Oracle**: AtÃ© setembro de 2029 (Extended atÃ© 2032)
- **ğŸ†“ Suporte Gratuito**: Eclipse Temurin, Amazon Corretto, Microsoft OpenJDK
- **ğŸ¯ Status**: **LTS recomendada** para novos projetos
- **ğŸ”„ MigraÃ§Ã£o**: Moderada - requer anÃ¡lise de internal APIs

---

## ğŸ”— Links Ãšteis

### ğŸ“š **DocumentaÃ§Ã£o Oficial**
- [Java 17 Documentation](https://docs.oracle.com/en/java/javase/17/)
- [Java 17 API Specification](https://docs.oracle.com/en/java/javase/17/docs/api/)
- [All JEPs in Java 17](https://openjdk.org/projects/jdk/17/)

### ğŸ”„ **MigraÃ§Ã£o**
- [Migration Guide to Java 17](https://docs.oracle.com/en/java/javase/17/migrate/)
- [Strongly Encapsulated JDK Internals](https://openjdk.org/jeps/403)
- [Third-party Alternatives](https://adoptium.net/migration/)

### ğŸ—ï¸ **Records e Sealed Classes**
- [Records Tutorial](https://www.baeldung.com/java-record-keyword)
- [Sealed Classes Guide](https://www.baeldung.com/java-sealed-classes-interfaces)
- [Pattern Matching Examples](https://openjdk.org/jeps/394)

### ğŸ¯ **Switch Expressions**
- [Switch Expressions Tutorial](https://www.baeldung.com/java-switch)
- [Modern Java Patterns](https://github.com/winterbe/java8-tutorial)

### ğŸ’» **Ferramentas e Performance**
- [jpackage Guide](https://docs.oracle.com/en/java/javase/17/docs/specs/man/jpackage.html)
- [Apple Silicon Performance](https://www.baeldung.com/java-apple-silicon)
- [GC Tuning Guide](https://docs.oracle.com/en/java/javase/17/gctuning/)

### ğŸŒŸ **Exemplos PrÃ¡ticos**
- [Java 17 Features with Examples](https://www.baeldung.com/java-17-new-features)
- [Modern Java Development](https://github.com/openjdk/jdk17)
- [Real-world Java 17 Usage](https://foojay.io/today/java-17-the-new-lts-is-here/) 