# 1Ô∏è‚É£0Ô∏è‚É£ Java 10 (2018)

# üöÄ Java 10 - Infer√™ncia de Tipos e Performance

## üìñ Sobre o Java 10

Java 10 foi o primeiro release no novo ciclo de 6 meses, lan√ßado apenas 6 meses ap√≥s o Java 9. Embora menor em escopo, trouxe uma das funcionalidades mais aguardadas pelos desenvolvedores: **Local Variable Type Inference** com a palavra-chave `var`.

## üí° O que s√£o JEPs?
Java 10 incluiu 12 JEPs focados principalmente em melhorias de performance, developer experience e prepara√ß√£o para funcionalidades futuras.

---

## üéØ Melhorias na Linguagem

### üîπ JEP 286: Local Variable Type Inference

#### ‚ùì O que √©?
Permite que o compilador infira automaticamente o tipo de vari√°veis locais usando a palavra-chave `var`, similar ao que existe em C# e outras linguagens modernas.

#### ‚ö†Ô∏è Por que √© importante?
Reduz verbosidade do c√≥digo Java, especialmente com tipos gen√©ricos complexos, tornando o c√≥digo mais leg√≠vel e mantendo a type safety em tempo de compila√ß√£o.

```java
// Antes do Java 10 - Verboso com tipos longos
List<String> nomes = new ArrayList<String>();
Map<String, List<Person>> pessoasPorCidade = new HashMap<String, List<Person>>();
Iterator<Entry<String, Integer>> iterator = map.entrySet().iterator();

// Java 10 - Mais limpo com var
var nomes = new ArrayList<String>();           // List<String> inferido
var pessoasPorCidade = new HashMap<String, List<Person>>(); // Map<String, List<Person>>
var iterator = map.entrySet().iterator();      // Iterator<Entry<String, Integer>>

// Casos simples
var nome = "Jo√£o Silva";        // String
var idade = 30;                 // int
var salario = 5500.50;         // double
var ativo = true;              // boolean

// Com Streams - elimina types complexos
var nomesComJ = List.of("Ana", "Jo√£o", "Maria", "Jos√©")
    .stream()
    .filter(s -> s.startsWith("J"))
    .map(String::toUpperCase)
    .collect(Collectors.toList());  // List<String> inferido

// Diamond operator fica mais limpo
var pessoas = new ArrayList<Person>();
var cache = new ConcurrentHashMap<String, Object>();

// Com try-with-resources
try (var scanner = new Scanner(System.in);
     var writer = Files.newBufferedWriter(path)) {
    // c√≥digo aqui
}
```

#### ‚ö†Ô∏è Limita√ß√µes e Regras do var

```java
public class VarExamples {
    // ‚ùå N√ÉO funciona em:
    
    // 1. Campos de classe
    // var campoDeClasse = "erro";  // ERRO
    
    // 2. Par√¢metros de m√©todo
    // public void metodo(var param) { }  // ERRO
    
    // 3. Tipo de retorno
    // public var metodo() { return "erro"; }  // ERRO
    
    // 4. Sem inicializa√ß√£o
    public void exemplos() {
        // var sem_valor;  // ERRO - precisa de inicializa√ß√£o
        
        // 5. Inicializa√ß√£o com null
        // var nulo = null;  // ERRO - tipo n√£o pode ser inferido
        
        // 6. Lambdas precisam de contexto
        // var lambda = () -> "test";  // ERRO
        // var lambda = (String s) -> s.toUpperCase();  // ERRO
        
        // ‚úÖ Mas funciona com:
        Function<String, String> func = s -> s.toUpperCase();
        var lambda = func;  // OK - tipo Function<String, String> inferido
        
        // 7. Array precisa de tipo expl√≠cito no lado direito
        // var array = {1, 2, 3};  // ERRO
        var array = new int[]{1, 2, 3};  // OK
        
        // 8. Express√µes polim√≥rficas precisam de cast
        var number = (Number) 42;  // OK - sem cast seria int
    }
}
```

#### üéØ Boas Pr√°ticas com var

```java
// ‚úÖ BOM: Quando o tipo √© √≥bvio do lado direito
var path = Paths.get("arquivo.txt");
var date = LocalDate.now();
var users = userService.findAllUsers();

// ‚úÖ BOM: Com tipos gen√©ricos complexos
var complexMap = new HashMap<String, List<Map<String, Object>>>();

// ‚ùå EVITAR: Quando o tipo n√£o √© claro
var data = getData();        // Que tipo retorna getData()?
var result = process();      // N√£o fica claro o tipo

// ‚úÖ MELHOR: Seja expl√≠cito quando necess√°rio
UserDto userData = getData();
ProcessResult result = process();

// ‚úÖ BOM: Em loops for-each
for (var person : pessoas) {
    System.out.println(person.getName());
}

// ‚úÖ BOM: Com APIs fluentes
var result = Optional.of("test")
    .map(String::toUpperCase)
    .filter(s -> s.length() > 3)
    .orElse("default");
```

#### üîç Verificando Tipos Inferidos

```java
// No IDE ou compila√ß√£o, voc√™ pode verificar que tipo foi inferido
var list = new ArrayList<String>();
// Hover no IDE mostra: ArrayList<String>

var stream = list.stream()
    .filter(s -> s.startsWith("A"))
    .map(String::toUpperCase);
// Tipo inferido: Stream<String>
```

üìö **Saiba mais**: [Local Variable Type Inference Guide](https://openjdk.org/jeps/286)

---

## üóëÔ∏è Melhorias no Garbage Collection

### üîπ JEP 307: Parallel Full GC para G1

#### ‚ùì O que √©?
Melhora o G1 Garbage Collector implementando Full GC paralelo, reduzindo o tempo de pausas longas.

#### ‚ö†Ô∏è Por que √© importante?
Antes, o G1 usava single-threaded full GC como fallback, causando pausas muito longas. Agora usa parallel full GC, melhorando significativamente a performance.

```bash
# G1GC com parallel full GC (padr√£o no Java 10+)
java -XX:+UseG1GC MyApplication

# Verificar configura√ß√µes do G1
java -XX:+UseG1GC -XX:+PrintGCDetails MyApplication

# Tuning t√≠pico do G1
java -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=200 \
     -XX:G1HeapRegionSize=16m \
     MyApplication
```

### üîπ JEP 317: Experimental Garbage Collectors

#### ‚ùì O que √©?
Introduz Epsilon GC, um garbage collector "no-op" que aloca mem√≥ria mas nunca coleta.

#### ‚ö†Ô∏è Por que √© importante?
√ötil para testes de performance, aplica√ß√µes de vida curta, ou quando voc√™ quer medir overhead do GC.

```bash
# Epsilon GC - sem coleta de lixo
java -XX:+UnlockExperimentalVMOptions \
     -XX:+UseEpsilonGC \
     MyShortLivedApp

# √ötil para:
# - Benchmarks de performance
# - Aplica√ß√µes que sabem que n√£o precisam de GC
# - Testes de vazamento de mem√≥ria
```

---

## üöÄ Performance e JVM

### üîπ JEP 310: Application Class-Data Sharing

#### ‚ùì O que √©?
Estende CDS (Class Data Sharing) para permitir compartilhar metadados de classes de aplica√ß√£o, n√£o apenas classes do sistema.

#### ‚ö†Ô∏è Por que √© importante?
Reduz tempo de startup e footprint de mem√≥ria ao compartilhar dados de classes entre m√∫ltiplas JVMs.

```bash
# 1. Criar lista de classes para CDS
java -XX:+UseAppCDS \
     -XX:DumpLoadedClassList=classes.lst \
     MyApplication

# 2. Criar arquivo CDS
java -XX:+UseAppCDS \
     -Xshare:dump \
     -XX:SharedClassListFile=classes.lst \
     -XX:SharedArchiveFile=app-cds.jsa \
     -cp myapp.jar

# 3. Usar CDS em produ√ß√£o
java -XX:+UseAppCDS \
     -Xshare:on \
     -XX:SharedArchiveFile=app-cds.jsa \
     -cp myapp.jar MyApplication

# Benef√≠cios:
# - Startup 20-30% mais r√°pido
# - 10-15% menos uso de mem√≥ria
# - Especialmente √∫til em containers/microservices
```

### üîπ JEP 312: Thread-Local Handshakes

#### ‚ùì O que √©?
Permite executar callbacks em threads espec√≠ficas sem parar todas as threads em uma parada global.

#### ‚ö†Ô∏è Por que √© importante?
Melhora lat√™ncia reduzindo pause times, especialmente importante para aplica√ß√µes de baixa lat√™ncia.

```java
// Transparente para desenvolvedores - melhoria interna da JVM
// Beneficia opera√ß√µes como:
// - Biased locking revocation
// - Stack sampling
// - Algumas opera√ß√µes de debug/profiling

// Antes: Para todas as threads
// Agora: Para apenas threads espec√≠ficas quando necess√°rio
```

---

## üìö Melhorias em APIs

### üîπ JEP 296: Consolidar Reposit√≥rios JDK

#### ‚ùì O que √©?
Consolida reposit√≥rios do OpenJDK em um √∫nico reposit√≥rio para facilitar desenvolvimento.

### üîπ Optional.orElseThrow() sem par√¢metros

#### ‚ùì O que √©?
Adiciona m√©todo `orElseThrow()` sem par√¢metros ao Optional, equivalente a `get()` mas mais expressivo.

#### ‚ö†Ô∏è Por que √© importante?
Torna o c√≥digo mais expressivo sobre a inten√ß√£o de que se espera um valor presente.

```java
Optional<String> nome = findUserName(id);

// Java 8-9: verboso ou confuso
String valor1 = nome.get();  // Confuso - pode dar exce√ß√£o
String valor2 = nome.orElseThrow(NoSuchElementException::new);  // Verboso

// Java 10: expressivo e conciso
String valor3 = nome.orElseThrow();  // Claro que pode lan√ßar exce√ß√£o

// Exemplo pr√°tico
public User findUserById(Long id) {
    return userRepository.findById(id)
        .orElseThrow();  // NoSuchElementException se n√£o encontrar
}

// Com mensagem customizada (ainda melhor)
public User findUserByIdWithMessage(Long id) {
    return userRepository.findById(id)
        .orElseThrow(() -> new UserNotFoundException("User not found: " + id));
}
```

### üîπ Collectors.toUnmodifiable*()

#### ‚ùì O que √©?
Novos collectors que retornam cole√ß√µes imut√°veis diretamente.

#### ‚ö†Ô∏è Por que √© importante?
Elimina necessidade de wrap com `Collections.unmodifiable*()` ap√≥s coletar.

```java
// Antes do Java 10
List<String> imutavelAntes = pessoas.stream()
    .map(Person::getName)
    .collect(Collectors.toList());
imutavelAntes = Collections.unmodifiableList(imutavelAntes);  // Wrap necess√°rio

// Java 10 - direto
List<String> imutavel = pessoas.stream()
    .map(Person::getName)
    .collect(Collectors.toUnmodifiableList());

Set<String> emails = pessoas.stream()
    .map(Person::getEmail)
    .collect(Collectors.toUnmodifiableSet());

Map<String, Integer> idades = pessoas.stream()
    .collect(Collectors.toUnmodifiableMap(
        Person::getName, 
        Person::getAge
    ));

// Tentativa de modifica√ß√£o resulta em UnsupportedOperationException
// imutavel.add("novo");  // ‚ùå Erro em runtime
```

### üîπ List.copyOf(), Set.copyOf(), Map.copyOf()

#### ‚ùì O que √©?
M√©todos est√°ticos para criar c√≥pias imut√°veis de cole√ß√µes existentes.

#### ‚ö†Ô∏è Por que √© importante?
Forma segura de criar c√≥pias imut√°veis, lidando corretamente com cole√ß√µes j√° imut√°veis.

```java
List<String> original = Arrays.asList("a", "b", "c");
List<String> copia = List.copyOf(original);  // C√≥pia imut√°vel

// Otimiza√ß√£o inteligente: se original j√° for imut√°vel, retorna a mesma inst√¢ncia
List<String> jaImutavel = List.of("x", "y", "z");
List<String> "copia"2 = List.copyOf(jaImutavel);  // Retorna a mesma inst√¢ncia!
System.out.println(jaImutavel == copia2);  // true - mesma refer√™ncia

// Funciona com qualquer Collection
Set<String> conjuntoOriginal = new HashSet<>(Arrays.asList("1", "2", "3"));
Set<String> conjuntoCopia = Set.copyOf(conjuntoOriginal);  // Imut√°vel

Map<String, Integer> mapaOriginal = new HashMap<>();
mapaOriginal.put("a", 1);
mapaOriginal.put("b", 2);
Map<String, Integer> mapaCopia = Map.copyOf(mapaOriginal);  // Imut√°vel

// Null safety - elementos null causam NullPointerException
List<String> comNull = Arrays.asList("a", null, "c");
// List<String> erro = List.copyOf(comNull);  // ‚ùå NullPointerException
```

---

## üîß Outras Melhorias

### üîπ JEP 313: Remove the Native-Header Generation Tool (javah)

#### ‚ùì O que √©?
Remove a ferramenta `javah` que foi substitu√≠da por `javac -h`.

```bash
# Antes: javah
javah -jni MyClass

# Agora: javac com -h
javac -h . MyClass.java
```

### üîπ JEP 314: Additional Unicode Language-Tag Extensions

#### ‚ùì O que √©?
Suporte adicional para Unicode Language-Tag Extensions.

### üîπ JEP 316: Heap Allocation on Alternative Memory Devices

#### ‚ùì O que √©?
Permite alocar heap em dispositivos de mem√≥ria alternativos (como NV-DIMM).

```bash
# Usar mem√≥ria alternativa para heap
java -XX:AllocateHeapAt=/mnt/nvdimm MyApplication
```

---

## üéØ Impacto e Ado√ß√£o

Java 10 estabeleceu o **novo ritmo de releases**:

- ‚úÖ **`var` keyword** reduziu verbosidade significativamente
- ‚úÖ **Performance melhorada** com G1 parallel full GC
- ‚úÖ **Startup mais r√°pido** com Application CDS
- ‚úÖ **Novo modelo de release** de 6 meses funciona
- ‚úÖ **Base para inova√ß√µes** futuras nos releases seguintes

---

## üìÖ Informa√ß√µes da Vers√£o

- **üìÖ Lan√ßamento**: 20 de mar√ßo de 2018
- **üîß Tipo**: Feature Release
- **‚ö° Suporte**: Terminado em setembro de 2018 
- **üéØ Status**: Primeiro release no ciclo de 6 meses
- **üîÑ Migra√ß√£o**: F√°cil - principalmente additive features

---

## üîó Links √öteis

### üìö **Documenta√ß√£o Oficial**
- [Java 10 Documentation](https://docs.oracle.com/javase/10/)
- [Java 10 API Specification](https://docs.oracle.com/javase/10/docs/api/)
- [All JEPs in Java 10](https://openjdk.org/projects/jdk/10/)

### üéØ **Local Variable Type Inference**
- [JEP 286: Local-Variable Type Inference](https://openjdk.org/jeps/286)
- [var keyword style guide](https://openjdk.org/projects/amber/guides/lvti-style-guide)
- [Local Variable Type Inference FAQ](https://openjdk.org/projects/amber/guides/lvti-faq)

### üóëÔ∏è **Garbage Collection**
- [G1 Garbage Collector](https://docs.oracle.com/javase/10/gctuning/garbage-first-garbage-collector.htm)
- [Epsilon GC Documentation](https://openjdk.org/jeps/318)
- [Application Class Data Sharing](https://openjdk.org/jeps/310)

### üíª **Exemplos e Guias**
- [Java 10 var examples](https://www.baeldung.com/java-10-local-variable-type-inference)
- [Migration Guide to Java 10](https://blog.codefx.org/java/java-10-guide/)
- [Performance improvements in Java 10](https://www.optaplanner.org/blog/2018/07/03/JavaGCtuningAndSpeedTransitions.html) 