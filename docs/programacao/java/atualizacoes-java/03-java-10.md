# 1ï¸âƒ£0ï¸âƒ£ Java 10 (2018)

# ğŸš€ Java 10 - InferÃªncia de Tipos e Performance

## ğŸ“– Sobre o Java 10

Java 10 foi o primeiro release no novo ciclo de 6 meses, lanÃ§ado apenas 6 meses apÃ³s o Java 9. Embora menor em escopo, trouxe uma das funcionalidades mais aguardadas pelos desenvolvedores: **Local Variable Type Inference** com a palavra-chave `var`.

## ğŸ’¡ O que sÃ£o JEPs?
Java 10 incluiu 12 JEPs focados principalmente em melhorias de performance, developer experience e preparaÃ§Ã£o para funcionalidades futuras.

---

## ğŸ¯ Melhorias na Linguagem

### ğŸ”¹ JEP 286: Local Variable Type Inference

#### â“ O que Ã©?
Permite que o compilador infira automaticamente o tipo de variÃ¡veis locais usando a palavra-chave `var`, similar ao que existe em C# e outras linguagens modernas.

#### âš ï¸ Por que Ã© importante?
Reduz verbosidade do cÃ³digo Java, especialmente com tipos genÃ©ricos complexos, tornando o cÃ³digo mais legÃ­vel e mantendo a type safety em tempo de compilaÃ§Ã£o.

```java
// Antes do Java 10 - Verboso com tipos longos
List<String> nomes = new ArrayList<String>();
Map<String, List<Person>> pessoasPorCidade = new HashMap<String, List<Person>>();
Iterator<Entry<String, Integer>> iterator = map.entrySet().iterator();

// Java 10 - Mais limpo com var
var nomes = new ArrayList<String>();           // List<String> inferido
var pessoasPorCidade = new HashMap<String, List<Person>>(); // Map<String, List<Person>>
var iterator = map.entrySet().iterator();      // Iterator<Entry<String, Integer>>

// Casos simples
var nome = "JoÃ£o Silva";        // String
var idade = 30;                 // int
var salario = 5500.50;         // double
var ativo = true;              // boolean

// Com Streams - elimina types complexos
var nomesComJ = List.of("Ana", "JoÃ£o", "Maria", "JosÃ©")
    .stream()
    .filter(s -> s.startsWith("J"))
    .map(String::toUpperCase)
    .collect(Collectors.toList());  // List<String> inferido

// Diamond operator fica mais limpo
var pessoas = new ArrayList<Person>();
var cache = new ConcurrentHashMap<String, Object>();

// Com try-with-resources
try (var scanner = new Scanner(System.in);
     var writer = Files.newBufferedWriter(path)) {
    // cÃ³digo aqui
}
```

#### âš ï¸ LimitaÃ§Ãµes e Regras do var

```java
public class VarExamples {
    // âŒ NÃƒO funciona em:
    
    // 1. Campos de classe
    // var campoDeClasse = "erro";  // ERRO
    
    // 2. ParÃ¢metros de mÃ©todo
    // public void metodo(var param) { }  // ERRO
    
    // 3. Tipo de retorno
    // public var metodo() { return "erro"; }  // ERRO
    
    // 4. Sem inicializaÃ§Ã£o
    public void exemplos() {
        // var sem_valor;  // ERRO - precisa de inicializaÃ§Ã£o
        
        // 5. InicializaÃ§Ã£o com null
        // var nulo = null;  // ERRO - tipo nÃ£o pode ser inferido
        
        // 6. Lambdas precisam de contexto
        // var lambda = () -> "test";  // ERRO
        // var lambda = (String s) -> s.toUpperCase();  // ERRO
        
        // âœ… Mas funciona com:
        Function<String, String> func = s -> s.toUpperCase();
        var lambda = func;  // OK - tipo Function<String, String> inferido
        
        // 7. Array precisa de tipo explÃ­cito no lado direito
        // var array = {1, 2, 3};  // ERRO
        var array = new int[]{1, 2, 3};  // OK
        
        // 8. ExpressÃµes polimÃ³rficas precisam de cast
        var number = (Number) 42;  // OK - sem cast seria int
    }
}
```

#### ğŸ¯ Boas PrÃ¡ticas com var

```java
// âœ… BOM: Quando o tipo Ã© Ã³bvio do lado direito
var path = Paths.get("arquivo.txt");
var date = LocalDate.now();
var users = userService.findAllUsers();

// âœ… BOM: Com tipos genÃ©ricos complexos
var complexMap = new HashMap<String, List<Map<String, Object>>>();

// âŒ EVITAR: Quando o tipo nÃ£o Ã© claro
var data = getData();        // Que tipo retorna getData()?
var result = process();      // NÃ£o fica claro o tipo

// âœ… MELHOR: Seja explÃ­cito quando necessÃ¡rio
UserDto userData = getData();
ProcessResult result = process();

// âœ… BOM: Em loops for-each
for (var person : pessoas) {
    System.out.println(person.getName());
}

// âœ… BOM: Com APIs fluentes
var result = Optional.of("test")
    .map(String::toUpperCase)
    .filter(s -> s.length() > 3)
    .orElse("default");
```

#### ğŸ” Verificando Tipos Inferidos

```java
// No IDE ou compilaÃ§Ã£o, vocÃª pode verificar que tipo foi inferido
var list = new ArrayList<String>();
// Hover no IDE mostra: ArrayList<String>

var stream = list.stream()
    .filter(s -> s.startsWith("A"))
    .map(String::toUpperCase);
// Tipo inferido: Stream<String>
```

ğŸ“š **Saiba mais**: [Local Variable Type Inference Guide](https://openjdk.org/jeps/286)

---

## ğŸ—‘ï¸ Melhorias no Garbage Collection

### ğŸ”¹ JEP 307: Parallel Full GC para G1

#### â“ O que Ã©?
Melhora o G1 Garbage Collector implementando Full GC paralelo, reduzindo o tempo de pausas longas.

#### âš ï¸ Por que Ã© importante?
Antes, o G1 usava single-threaded full GC como fallback, causando pausas muito longas. Agora usa parallel full GC, melhorando significativamente a performance.

```bash
# G1GC com parallel full GC (padrÃ£o no Java 10+)
java -XX:+UseG1GC MyApplication

# Verificar configuraÃ§Ãµes do G1
java -XX:+UseG1GC -XX:+PrintGCDetails MyApplication

# Tuning tÃ­pico do G1
java -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=200 \
     -XX:G1HeapRegionSize=16m \
     MyApplication
```

### ğŸ”¹ JEP 317: Experimental Garbage Collectors

#### â“ O que Ã©?
Introduz Epsilon GC, um garbage collector "no-op" que aloca memÃ³ria mas nunca coleta.

#### âš ï¸ Por que Ã© importante?
Ãštil para testes de performance, aplicaÃ§Ãµes de vida curta, ou quando vocÃª quer medir overhead do GC.

```bash
# Epsilon GC - sem coleta de lixo
java -XX:+UnlockExperimentalVMOptions \
     -XX:+UseEpsilonGC \
     MyShortLivedApp

# Ãštil para:
# - Benchmarks de performance
# - AplicaÃ§Ãµes que sabem que nÃ£o precisam de GC
# - Testes de vazamento de memÃ³ria
```

---

## ğŸš€ Performance e JVM

### ğŸ”¹ JEP 310: Application Class-Data Sharing

#### â“ O que Ã©?
Estende CDS (Class Data Sharing) para permitir compartilhar metadados de classes de aplicaÃ§Ã£o, nÃ£o apenas classes do sistema.

#### âš ï¸ Por que Ã© importante?
Reduz tempo de startup e footprint de memÃ³ria ao compartilhar dados de classes entre mÃºltiplas JVMs.

```bash
# 1. Criar lista de classes para CDS
java -XX:+UseAppCDS \
     -XX:DumpLoadedClassList=classes.lst \
     MyApplication

# 2. Criar arquivo CDS
java -XX:+UseAppCDS \
     -Xshare:dump \
     -XX:SharedClassListFile=classes.lst \
     -XX:SharedArchiveFile=app-cds.jsa \
     -cp myapp.jar

# 3. Usar CDS em produÃ§Ã£o
java -XX:+UseAppCDS \
     -Xshare:on \
     -XX:SharedArchiveFile=app-cds.jsa \
     -cp myapp.jar MyApplication

# BenefÃ­cios:
# - Startup 20-30% mais rÃ¡pido
# - 10-15% menos uso de memÃ³ria
# - Especialmente Ãºtil em containers/microservices
```

### ğŸ”¹ JEP 312: Thread-Local Handshakes

#### â“ O que Ã©?
Permite executar callbacks em threads especÃ­ficas sem parar todas as threads em uma parada global.

#### âš ï¸ Por que Ã© importante?
Melhora latÃªncia reduzindo pause times, especialmente importante para aplicaÃ§Ãµes de baixa latÃªncia.

```java
// Transparente para desenvolvedores - melhoria interna da JVM
// Beneficia operaÃ§Ãµes como:
// - Biased locking revocation
// - Stack sampling
// - Algumas operaÃ§Ãµes de debug/profiling

// Antes: Para todas as threads
// Agora: Para apenas threads especÃ­ficas quando necessÃ¡rio
```

---

## ğŸ“š Melhorias em APIs

### ğŸ”¹ JEP 296: Consolidar RepositÃ³rios JDK

#### â“ O que Ã©?
Consolida repositÃ³rios do OpenJDK em um Ãºnico repositÃ³rio para facilitar desenvolvimento.

### ğŸ”¹ Optional.orElseThrow() sem parÃ¢metros

#### â“ O que Ã©?
Adiciona mÃ©todo `orElseThrow()` sem parÃ¢metros ao Optional, equivalente a `get()` mas mais expressivo.

#### âš ï¸ Por que Ã© importante?
Torna o cÃ³digo mais expressivo sobre a intenÃ§Ã£o de que se espera um valor presente.

```java
Optional<String> nome = findUserName(id);

// Java 8-9: verboso ou confuso
String valor1 = nome.get();  // Confuso - pode dar exceÃ§Ã£o
String valor2 = nome.orElseThrow(NoSuchElementException::new);  // Verboso

// Java 10: expressivo e conciso
String valor3 = nome.orElseThrow();  // Claro que pode lanÃ§ar exceÃ§Ã£o

// Exemplo prÃ¡tico
public User findUserById(Long id) {
    return userRepository.findById(id)
        .orElseThrow();  // NoSuchElementException se nÃ£o encontrar
}

// Com mensagem customizada (ainda melhor)
public User findUserByIdWithMessage(Long id) {
    return userRepository.findById(id)
        .orElseThrow(() -> new UserNotFoundException("User not found: " + id));
}
```

### ğŸ”¹ Collectors.toUnmodifiable*()

#### â“ O que Ã©?
Novos collectors que retornam coleÃ§Ãµes imutÃ¡veis diretamente.

#### âš ï¸ Por que Ã© importante?
Elimina necessidade de wrap com `Collections.unmodifiable*()` apÃ³s coletar.

```java
// Antes do Java 10
List<String> imutavelAntes = pessoas.stream()
    .map(Person::getName)
    .collect(Collectors.toList());
imutavelAntes = Collections.unmodifiableList(imutavelAntes);  // Wrap necessÃ¡rio

// Java 10 - direto
List<String> imutavel = pessoas.stream()
    .map(Person::getName)
    .collect(Collectors.toUnmodifiableList());

Set<String> emails = pessoas.stream()
    .map(Person::getEmail)
    .collect(Collectors.toUnmodifiableSet());

Map<String, Integer> idades = pessoas.stream()
    .collect(Collectors.toUnmodifiableMap(
        Person::getName, 
        Person::getAge
    ));

// Tentativa de modificaÃ§Ã£o resulta em UnsupportedOperationException
// imutavel.add("novo");  // âŒ Erro em runtime
```

### ğŸ”¹ List.copyOf(), Set.copyOf(), Map.copyOf()

#### â“ O que Ã©?
MÃ©todos estÃ¡ticos para criar cÃ³pias imutÃ¡veis de coleÃ§Ãµes existentes.

#### âš ï¸ Por que Ã© importante?
Forma segura de criar cÃ³pias imutÃ¡veis, lidando corretamente com coleÃ§Ãµes jÃ¡ imutÃ¡veis.

```java
List<String> original = Arrays.asList("a", "b", "c");
List<String> copia = List.copyOf(original);  // CÃ³pia imutÃ¡vel

// OtimizaÃ§Ã£o inteligente: se original jÃ¡ for imutÃ¡vel, retorna a mesma instÃ¢ncia
List<String> jaImutavel = List.of("x", "y", "z");
List<String> "copia"2 = List.copyOf(jaImutavel);  // Retorna a mesma instÃ¢ncia!
System.out.println(jaImutavel == copia2);  // true - mesma referÃªncia

// Funciona com qualquer Collection
Set<String> conjuntoOriginal = new HashSet<>(Arrays.asList("1", "2", "3"));
Set<String> conjuntoCopia = Set.copyOf(conjuntoOriginal);  // ImutÃ¡vel

Map<String, Integer> mapaOriginal = new HashMap<>();
mapaOriginal.put("a", 1);
mapaOriginal.put("b", 2);
Map<String, Integer> mapaCopia = Map.copyOf(mapaOriginal);  // ImutÃ¡vel

// Null safety - elementos null causam NullPointerException
List<String> comNull = Arrays.asList("a", null, "c");
// List<String> erro = List.copyOf(comNull);  // âŒ NullPointerException
```

---

## ğŸ”§ Outras Melhorias

### ğŸ”¹ JEP 313: Remove the Native-Header Generation Tool (javah)

#### â“ O que Ã©?
Remove a ferramenta `javah` que foi substituÃ­da por `javac -h`.

```bash
# Antes: javah
javah -jni MyClass

# Agora: javac com -h
javac -h . MyClass.java
```

### ğŸ”¹ JEP 314: Additional Unicode Language-Tag Extensions

#### â“ O que Ã©?
Suporte adicional para Unicode Language-Tag Extensions.

### ğŸ”¹ JEP 316: Heap Allocation on Alternative Memory Devices

#### â“ O que Ã©?
Permite alocar heap em dispositivos de memÃ³ria alternativos (como NV-DIMM).

```bash
# Usar memÃ³ria alternativa para heap
java -XX:AllocateHeapAt=/mnt/nvdimm MyApplication
```

---

## ğŸ¯ Impacto e AdoÃ§Ã£o

Java 10 estabeleceu o **novo ritmo de releases**:

- âœ… **`var` keyword** reduziu verbosidade significativamente
- âœ… **Performance melhorada** com G1 parallel full GC
- âœ… **Startup mais rÃ¡pido** com Application CDS
- âœ… **Novo modelo de release** de 6 meses funciona
- âœ… **Base para inovaÃ§Ãµes** futuras nos releases seguintes

---

## ğŸ“… InformaÃ§Ãµes da VersÃ£o

- **ğŸ“… LanÃ§amento**: 20 de marÃ§o de 2018
- **ğŸ”§ Tipo**: Feature Release
- **âš¡ Suporte**: Terminado em setembro de 2018 
- **ğŸ¯ Status**: Primeiro release no ciclo de 6 meses
- **ğŸ”„ MigraÃ§Ã£o**: FÃ¡cil - principalmente additive features

---

## ğŸ”— Links Ãšteis

### ğŸ“š **DocumentaÃ§Ã£o Oficial**
- [Java 10 Documentation](https://docs.oracle.com/javase/10/)
- [Java 10 API Specification](https://docs.oracle.com/javase/10/docs/api/)
- [All JEPs in Java 10](https://openjdk.org/projects/jdk/10/)

### ğŸ¯ **Local Variable Type Inference**
- [JEP 286: Local-Variable Type Inference](https://openjdk.org/jeps/286)
- [var keyword style guide](https://openjdk.org/projects/amber/guides/lvti-style-guide)
- [Local Variable Type Inference FAQ](https://openjdk.org/projects/amber/guides/lvti-faq)

### ğŸ—‘ï¸ **Garbage Collection**
- [G1 Garbage Collector](https://docs.oracle.com/javase/10/gctuning/garbage-first-garbage-collector.htm)
- [Epsilon GC Documentation](https://openjdk.org/jeps/318)
- [Application Class Data Sharing](https://openjdk.org/jeps/310)

### ğŸ’» **Exemplos e Guias**
- [Java 10 var examples](https://www.baeldung.com/java-10-local-variable-type-inference)
- [Migration Guide to Java 10](https://blog.codefx.org/java/java-10-guide/)
- [Performance improvements in Java 10](https://www.optaplanner.org/blog/2018/07/03/JavaGCtuningAndSpeedTransitions.html) 